diff --git a/src/engine/client/graphics.cpp b/src/engine/client/graphics.cpp
index 2e8a855..1dbe161 100644
diff --git a/src/engine/client/input.cpp b/src/engine/client/input.cpp
index 7ff8d6f..a91ccd3 100644
diff --git a/src/engine/client/input.h b/src/engine/client/input.h
index 34f880f..528c1e4 100644
diff --git a/src/engine/client/serverbrowser.cpp b/src/engine/client/serverbrowser.cpp
index 9634926..836e666 100644
diff --git a/src/engine/client/sound.cpp b/src/engine/client/sound.cpp
index 343fa2e..60ac7b7 100644
diff --git a/src/engine/input.h b/src/engine/input.h
index 93ceccd..1242b28 100644
diff --git a/src/engine/server/server.cpp b/src/engine/server/server.cpp
index 19745b3..ab0f312 100644
diff --git a/src/engine/shared/config.h b/src/engine/shared/config.h
index c6d8437..611af9e 100644
diff --git a/src/engine/shared/config_variables.h b/src/engine/shared/config_variables.h
index 025a9cf..e202614 100644
diff --git a/src/engine/shared/netban.cpp b/src/engine/shared/netban.cpp
index 707b709..b33b2ea 100644
diff --git a/src/engine/shared/netban.h b/src/engine/shared/netban.h
index 7016483..8d94245 100644
diff --git a/src/engine/shared/network.cpp b/src/engine/shared/network.cpp
index 13d6207..ada4b18 100644
diff --git a/src/engine/shared/network.h b/src/engine/shared/network.h
index b934563..ab193eb 100644
diff --git a/src/engine/shared/network_conn.cpp b/src/engine/shared/network_conn.cpp
index ff88509..6500f51 100644
diff --git a/src/game/client/components/binds.cpp b/src/game/client/components/binds.cpp
index 3feba98..44460b3 100644
--- a/src/game/client/components/binds.cpp
+++ b/src/game/client/components/binds.cpp
@@ -96,12 +96,16 @@ void CBinds::SetDefaults()
 	Bind('d', "+right");
 
 	Bind(KEY_SPACE, "+jump");
+	Bind(KEY_RCTRL, "+fire");
 	Bind(KEY_MOUSE_1, "+fire");
+	Bind(KEY_RETURN, "+hook");
 	Bind(KEY_MOUSE_2, "+hook");
 	Bind(KEY_LSHIFT, "+emote");
 	Bind(KEY_RSHIFT, "+spectate");
-	Bind(KEY_RIGHT, "spectate_next");
-	Bind(KEY_LEFT, "spectate_previous");
+	Bind(KEY_RIGHT, "+right");
+	Bind(KEY_LEFT, "+left");
+	Bind(KEY_UP, "+jump");
+	Bind(KEY_DOWN, "+hook");
 
 	Bind('1', "+weapon1");
 	Bind('2', "+weapon2");
@@ -112,6 +116,9 @@ void CBinds::SetDefaults()
 	Bind(KEY_MOUSE_WHEEL_UP, "+prevweapon");
 	Bind(KEY_MOUSE_WHEEL_DOWN, "+nextweapon");
 
+	Bind(KEY_PAGEUP, "+prevweapon");
+	Bind(KEY_PAGEDOWN, "+nextweapon");
+
 	Bind('t', "chat all");
 	Bind('y', "chat team");
 
diff --git a/src/game/client/components/chat.cpp b/src/game/client/components/chat.cpp
index e7952af..0789e3b 100644
diff --git a/src/game/client/components/controls.cpp b/src/game/client/components/controls.cpp
index c079079..64b88bb 100644
--- a/src/game/client/components/controls.cpp
+++ b/src/game/client/components/controls.cpp
@@ -1,5 +1,10 @@
 /* (c) Magnus Auvinen. See licence.txt in the root of the distribution for more information. */
 /* If you are missing that file, acquire a complete release at teeworlds.com.                */
+
+#if defined(__ANDROID__)
+#include <SDL.h>
+#endif
+
 #include <base/math.h>
 
 #include <engine/shared/config.h>
@@ -10,12 +15,42 @@
 #include <game/client/components/chat.h>
 #include <game/client/components/menus.h>
 #include <game/client/components/scoreboard.h>
+#include <engine/graphics.h>
 
 #include "controls.h"
 
+
+enum {	LEFT_JOYSTICK_X = 0, LEFT_JOYSTICK_Y = 1,
+		RIGHT_JOYSTICK_X = 2, RIGHT_JOYSTICK_Y = 3,
+		SECOND_RIGHT_JOYSTICK_X = 20, SECOND_RIGHT_JOYSTICK_Y = 21,
+		ORIENTATION_X = 8, ORIENTATION_Y = 9, ORIENTATION_Z = 10,
+		ACCELEROMETER_X = 0, ACCELEROMETER_Y = 1,
+		NUM_JOYSTICK_AXES = 22 };
+
+
 CControls::CControls()
 {
 	mem_zero(&m_LastData, sizeof(m_LastData));
+
+#if defined(__ANDROID__)
+	SDL_Init(SDL_INIT_JOYSTICK);
+	m_Joystick = SDL_JoystickOpen(0);
+	if( m_Joystick && SDL_JoystickNumAxes(m_Joystick) < NUM_JOYSTICK_AXES )
+	{
+		SDL_JoystickClose(m_Joystick);
+		m_Joystick = NULL;
+	}
+
+	m_Gamepad = SDL_JoystickOpen(2);
+
+	m_Accelerometer = NULL;
+
+	SDL_JoystickEventState(SDL_QUERY);
+
+	m_UsingGamepad = false;
+	if( getenv("OUYA") )
+		m_UsingGamepad = true;
+#endif
 }
 
 void CControls::OnReset()
@@ -31,6 +66,22 @@ void CControls::OnReset()
 
 	m_InputDirectionLeft = 0;
 	m_InputDirectionRight = 0;
+
+	m_JoystickFirePressed = false;
+	m_JoystickRunPressed = false;
+	m_JoystickTapTime = 0;
+	for( int i = 0; i < NUM_WEAPONS; i++ )
+		m_AmmoCount[i] = 0;
+	m_OldMouseX = m_OldMouseY = 0.0f;
+	m_Hook = 0;
+	m_RelaunchHook = false;
+	// Prevent launching hook right after respawning
+	if( g_Config.m_ClTouchscreenMode == TOUCHSCREEN_ACCELEROMETER )
+		m_RelaunchHook = true;
+#if defined(__ANDROID__)
+	if(!m_Accelerometer)
+		m_Accelerometer = SDL_JoystickOpen(1);
+#endif
 }
 
 void CControls::OnRelease()
@@ -41,6 +92,12 @@ void CControls::OnRelease()
 void CControls::OnPlayerDeath()
 {
 	m_LastData.m_WantedWeapon = m_InputData.m_WantedWeapon = 0;
+	for( int i = 0; i < NUM_WEAPONS; i++ )
+		m_AmmoCount[i] = 0;
+
+	// Prevent launching hook right after respawning
+	if( g_Config.m_ClTouchscreenMode == TOUCHSCREEN_ACCELEROMETER )
+		m_RelaunchHook = true;
 }
 
 static void ConKeyInputState(IConsole::IResult *pResult, void *pUserData)
@@ -83,7 +140,7 @@ void CControls::OnConsoleInit()
 	Console()->Register("+left", "", CFGFLAG_CLIENT, ConKeyInputState, &m_InputDirectionLeft, "Move left");
 	Console()->Register("+right", "", CFGFLAG_CLIENT, ConKeyInputState, &m_InputDirectionRight, "Move right");
 	Console()->Register("+jump", "", CFGFLAG_CLIENT, ConKeyInputState, &m_InputData.m_Jump, "Jump");
-	Console()->Register("+hook", "", CFGFLAG_CLIENT, ConKeyInputState, &m_InputData.m_Hook, "Hook");
+	Console()->Register("+hook", "", CFGFLAG_CLIENT, ConKeyInputState, &m_Hook, "Hook");
 	Console()->Register("+fire", "", CFGFLAG_CLIENT, ConKeyInputCounter, &m_InputData.m_Fire, "Fire");
 
 	{ static CInputSet s_Set = {this, &m_InputData.m_WantedWeapon, 1}; Console()->Register("+weapon1", "", CFGFLAG_CLIENT, ConKeyInputSet, (void *)&s_Set, "Switch to hammer"); }
@@ -103,6 +160,8 @@ void CControls::OnMessage(int Msg, void *pRawMsg)
 		CNetMsg_Sv_WeaponPickup *pMsg = (CNetMsg_Sv_WeaponPickup *)pRawMsg;
 		if(g_Config.m_ClAutoswitchWeapons)
 			m_InputData.m_WantedWeapon = pMsg->m_Weapon+1;
+		// We don't really know ammo count, until we'll switch to that weapon, but any non-zero count will suffice here
+		m_AmmoCount[pMsg->m_Weapon%NUM_WEAPONS] = 10;
 	}
 }
 
@@ -156,6 +215,8 @@ int CControls::SnapInput(int *pData)
 		if(!m_InputDirectionLeft && m_InputDirectionRight)
 			m_InputData.m_Direction = 1;
 
+		m_InputData.m_Hook = m_Hook && !m_RelaunchHook;
+
 		// stress testing
 		if(g_Config.m_DbgStress)
 		{
@@ -198,6 +259,99 @@ int CControls::SnapInput(int *pData)
 
 void CControls::OnRender()
 {
+#if defined(__ANDROID__)
+	int64 CurTime = time_get();
+	bool FireWasPressed = false;
+
+	if( m_Joystick && !m_UsingGamepad )
+	{
+		switch( g_Config.m_ClTouchscreenMode )
+		{
+			case TOUCHSCREEN_TWO_JOYSTICKS:
+				TouchscreenInputTwoJoysticks(CurTime, &FireWasPressed);
+				break;
+			case TOUCHSCREEN_THREE_JOYSTICKS:
+				TouchscreenInputThreeJoysticks(CurTime, &FireWasPressed);
+				break;
+			case TOUCHSCREEN_ACCELEROMETER:
+				TouchscreenInputAccelerometer(CurTime, &FireWasPressed);
+				break;
+			case TOUCHSCREEN_DDRACE:
+				TouchscreenInputDDRace(CurTime, &FireWasPressed);
+				break;
+			case TOUCHSCREEN_VOLUME_KEYS:
+				TouchscreenInputVolumeKeys(CurTime, &FireWasPressed);
+				break;
+		}
+	}
+
+	if( m_Gamepad )
+	{
+		enum {
+			GAMEPAD_DEAD_ZONE = 65536 / 8,
+		};
+
+		// Get input from left joystick
+		int RunX = SDL_JoystickGetAxis(m_Gamepad, LEFT_JOYSTICK_X);
+		int RunY = SDL_JoystickGetAxis(m_Gamepad, LEFT_JOYSTICK_Y);
+		if( m_UsingGamepad )
+		{
+			//m_InputDirectionLeft = (RunX < -GAMEPAD_DEAD_ZONE);
+			//m_InputDirectionRight = (RunX > GAMEPAD_DEAD_ZONE);
+			static int OldRunX = 0, OldRunY = 0;
+			if( RunX < -GAMEPAD_DEAD_ZONE && OldRunX >= -GAMEPAD_DEAD_ZONE )
+				m_InputDirectionLeft = 1;
+			if( RunX >= -GAMEPAD_DEAD_ZONE && OldRunX < -GAMEPAD_DEAD_ZONE )
+				m_InputDirectionLeft = 0;
+			if( RunX > GAMEPAD_DEAD_ZONE && OldRunX <= GAMEPAD_DEAD_ZONE )
+				m_InputDirectionRight = 1;
+			if( RunX <= GAMEPAD_DEAD_ZONE && OldRunX > GAMEPAD_DEAD_ZONE )
+				m_InputDirectionRight = 0;
+			OldRunX = RunX;
+			OldRunY = RunY;
+		}
+
+		// Get input from right joystick
+		int AimX = SDL_JoystickGetAxis(m_Gamepad, RIGHT_JOYSTICK_X);
+		int AimY = SDL_JoystickGetAxis(m_Gamepad, RIGHT_JOYSTICK_Y);
+		if( abs(AimX) > GAMEPAD_DEAD_ZONE || abs(AimY) > GAMEPAD_DEAD_ZONE )
+		{
+			m_MousePos = vec2(AimX / 30, AimY / 30);
+			ClampMousePos();
+		}
+
+		if( !m_UsingGamepad && (abs(AimX) > GAMEPAD_DEAD_ZONE || abs(AimY) > GAMEPAD_DEAD_ZONE ||
+			abs(RunX) > GAMEPAD_DEAD_ZONE || abs(RunY) > GAMEPAD_DEAD_ZONE) || SDL_GetMouseState(NULL, NULL) & SDL_BUTTON(SDL_BUTTON_RIGHT) )
+		{
+			UI()->AndroidShowScreenKeys(false);
+			m_UsingGamepad = true;
+		}
+	}
+
+	if( g_Config.m_ClAutoswitchWeaponsOutOfAmmo && m_pClient->m_Snap.m_pLocalCharacter )
+	{
+		// Keep track of ammo count, we know weapon ammo only when we switch to that weapon, this is tracked on server and protocol does not track that
+		m_AmmoCount[m_pClient->m_Snap.m_pLocalCharacter->m_Weapon%NUM_WEAPONS] = m_pClient->m_Snap.m_pLocalCharacter->m_AmmoCount;
+		// Autoswitch weapon if we're out of ammo
+		if( (m_InputData.m_Fire % 2 != 0 || FireWasPressed) &&
+			m_pClient->m_Snap.m_pLocalCharacter->m_AmmoCount == 0 &&
+			m_pClient->m_Snap.m_pLocalCharacter->m_Weapon != WEAPON_HAMMER &&
+			m_pClient->m_Snap.m_pLocalCharacter->m_Weapon != WEAPON_NINJA )
+		{
+			int w;
+			for( w = WEAPON_RIFLE; w > WEAPON_GUN; w-- )
+			{
+				if( w == m_pClient->m_Snap.m_pLocalCharacter->m_Weapon )
+					continue;
+				if( m_AmmoCount[w] > 0 )
+					break;
+			}
+			if( w != m_pClient->m_Snap.m_pLocalCharacter->m_Weapon )
+				m_InputData.m_WantedWeapon = w+1;
+		}
+	}
+#endif
+
 	// update target pos
 	if(m_pClient->m_Snap.m_pGameInfoObj && !m_pClient->m_Snap.m_SpecInfo.m_Active)
 		m_TargetPos = m_pClient->m_LocalCharacterPos + m_MousePos;
@@ -213,8 +367,20 @@ bool CControls::OnMouseMove(float x, float y)
 		(m_pClient->m_Snap.m_SpecInfo.m_Active && m_pClient->m_pChat->IsActive()))
 		return false;
 
+#if defined(__ANDROID__) // No relative mouse on Android
+	// We're using joystick on Android, mouse is disabled
+
+	if( m_OldMouseX != x || m_OldMouseY != y )
+	{
+		m_OldMouseX = x;
+		m_OldMouseY = y;
+		m_MousePos = vec2((x - g_Config.m_GfxScreenWidth/2), (y - g_Config.m_GfxScreenHeight/2));
+		ClampMousePos();
+	}
+#else
 	m_MousePos += vec2(x, y); // TODO: ugly
 	ClampMousePos();
+#endif
 
 	return true;
 }
@@ -225,7 +391,6 @@ void CControls::ClampMousePos()
 	{
 		m_MousePos.x = clamp(m_MousePos.x, 200.0f, Collision()->GetWidth()*32-200.0f);
 		m_MousePos.y = clamp(m_MousePos.y, 200.0f, Collision()->GetHeight()*32-200.0f);
-
 	}
 	else
 	{
@@ -237,3 +402,287 @@ void CControls::ClampMousePos()
 			m_MousePos = normalize(m_MousePos)*MouseMax;
 	}
 }
+
+#if defined(__ANDROID__)
+void CControls::TouchscreenInputTwoJoysticks(int64 CurTime, bool *FireWasPressed)
+{
+	// Get input from left joystick
+	int RunX = SDL_JoystickGetAxis(m_Joystick, LEFT_JOYSTICK_X);
+	int RunY = SDL_JoystickGetAxis(m_Joystick, LEFT_JOYSTICK_Y);
+	bool RunPressed = (RunX != 0 || RunY != 0);
+	// Get input from right joystick
+	int AimX = SDL_JoystickGetAxis(m_Joystick, RIGHT_JOYSTICK_X);
+	int AimY = SDL_JoystickGetAxis(m_Joystick, RIGHT_JOYSTICK_Y);
+	bool AimPressed = (AimX != 0 || AimY != 0);
+
+	if( m_JoystickRunPressed != RunPressed )
+	{
+		if( RunPressed && RunY < 0 )
+			m_InputData.m_Jump = 1;
+		else
+			m_InputData.m_Jump = 0;
+		m_JoystickTapTime = CurTime;
+	}
+
+	m_JoystickRunPressed = RunPressed;
+
+	if( RunPressed )
+	{
+		m_InputDirectionLeft = (RunX <= 0);
+		m_InputDirectionRight = (RunX > 0);
+	}
+
+	// Move 500ms in the same direction, to prevent speed bump when tapping
+	if( !RunPressed && m_JoystickTapTime + time_freq() / 2 > CurTime )
+	{
+		m_InputDirectionLeft = 0;
+		m_InputDirectionRight = 0;
+	}
+
+	if( AimPressed )
+	{
+		m_MousePos = vec2(AimX / 30, AimY / 30);
+		ClampMousePos();
+	}
+
+	m_RelaunchHook = false;
+}
+
+void CControls::TouchscreenInputThreeJoysticks(int64 CurTime, bool *FireWasPressed)
+{
+	// Get input from left joystick
+	int RunX = SDL_JoystickGetAxis(m_Joystick, LEFT_JOYSTICK_X);
+	int RunY = SDL_JoystickGetAxis(m_Joystick, LEFT_JOYSTICK_Y);
+	bool RunPressed = (RunX != 0 || RunY != 0);
+	// Get input from right joystick
+	int AimX = SDL_JoystickGetAxis(m_Joystick, RIGHT_JOYSTICK_X);
+	int AimY = SDL_JoystickGetAxis(m_Joystick, RIGHT_JOYSTICK_Y);
+	bool AimPressed = (AimX != 0 || AimY != 0);
+	// Get input from another right joystick
+	int HookX = SDL_JoystickGetAxis(m_Joystick, SECOND_RIGHT_JOYSTICK_X);
+	int HookY = SDL_JoystickGetAxis(m_Joystick, SECOND_RIGHT_JOYSTICK_Y);
+	bool HookPressed = (HookX != 0 || HookY != 0);
+
+	if( m_JoystickRunPressed != RunPressed )
+	{
+		if( RunPressed && RunY < 0 )
+			m_InputData.m_Jump = 1;
+		else
+			m_InputData.m_Jump = 0;
+		m_JoystickTapTime = CurTime;
+	}
+
+	m_JoystickRunPressed = RunPressed;
+
+	if( RunPressed )
+	{
+		m_InputDirectionLeft = (RunX <= 0);
+		m_InputDirectionRight = (RunX > 0);
+	}
+
+	// Move 500ms in the same direction, to prevent speed bump when tapping
+	if( !RunPressed && m_JoystickTapTime + time_freq() / 2 > CurTime )
+	{
+		m_InputDirectionLeft = 0;
+		m_InputDirectionRight = 0;
+	}
+
+	if( HookPressed )
+	{
+		m_MousePos = vec2(HookX / 30, HookY / 30);
+		ClampMousePos();
+		m_Hook = 1;
+	}
+	else
+	{
+		m_Hook = 0;
+	}
+
+	if( AimPressed )
+	{
+		m_MousePos = vec2(AimX / 30, AimY / 30);
+		ClampMousePos();
+	}
+
+	if( AimPressed != m_JoystickFirePressed )
+	{
+		// Fire when releasing joystick
+		if( !AimPressed )
+		{
+			m_InputData.m_Fire ++;
+			if( m_InputData.m_Fire % 2 != AimPressed )
+				m_InputData.m_Fire ++;
+			*FireWasPressed = true;
+		}
+	}
+
+	m_JoystickFirePressed = AimPressed;
+	m_RelaunchHook = false;
+}
+
+void CControls::TouchscreenInputAccelerometer(int64 CurTime, bool *FireWasPressed)
+{
+	int X = 0, Y = 0;
+	static int OldX = 0;
+
+	if( m_Accelerometer != NULL )
+	{
+		X = SDL_JoystickGetAxis(m_Accelerometer, ACCELEROMETER_X);
+		Y = SDL_JoystickGetAxis(m_Accelerometer, ACCELEROMETER_Y);
+	}
+
+	if( X >= g_Config.m_ClAccelerometerSensitivity && OldX < g_Config.m_ClAccelerometerSensitivity )
+		m_InputDirectionRight = 1;
+	if( X < g_Config.m_ClAccelerometerSensitivity && OldX >= g_Config.m_ClAccelerometerSensitivity )
+		m_InputDirectionRight = 0;
+	if( X <= -g_Config.m_ClAccelerometerSensitivity && OldX > -g_Config.m_ClAccelerometerSensitivity )
+		m_InputDirectionLeft = 1;
+	if( X > -g_Config.m_ClAccelerometerSensitivity && OldX <= -g_Config.m_ClAccelerometerSensitivity )
+		m_InputDirectionLeft = 0;
+
+	OldX = X;
+
+	// Get input from right joystick
+	int AimX = SDL_JoystickGetAxis(m_Joystick, LEFT_JOYSTICK_X);
+	int AimY = SDL_JoystickGetAxis(m_Joystick, LEFT_JOYSTICK_Y);
+	bool AimPressed = (AimX != 0 || AimY != 0);
+	static int OldAimX = 0, OldAimY = 0;
+	bool OldAimPressed = (OldAimX != 0 || OldAimY != 0);
+
+	if( AimPressed )
+	{
+		m_MousePos = vec2(AimX / 30, AimY / 30);
+		ClampMousePos();
+		m_Hook = 0;
+		if( !OldAimPressed )
+			m_RelaunchHook = false;
+	}
+	else
+	{
+		if (m_InputData.m_Fire % 2 == 0)
+			m_Hook = 1;
+	}
+	OldAimX = AimX;
+	OldAimY = AimY;
+}
+
+void CControls::TouchscreenInputDDRace(int64 CurTime, bool *FireWasPressed)
+{
+	// Get input from left joystick
+	int RunX = SDL_JoystickGetAxis(m_Joystick, LEFT_JOYSTICK_X);
+	int RunY = SDL_JoystickGetAxis(m_Joystick, LEFT_JOYSTICK_Y);
+	bool RunPressed = (RunX != 0 || RunY != 0);
+	// Get input from right joystick
+	int AimX = SDL_JoystickGetAxis(m_Joystick, RIGHT_JOYSTICK_X);
+	int AimY = SDL_JoystickGetAxis(m_Joystick, RIGHT_JOYSTICK_Y);
+	bool AimPressed = (AimX != 0 || AimY != 0);
+
+	if( m_JoystickRunPressed != RunPressed )
+	{
+		if( RunPressed && RunY < 0 )
+			m_InputData.m_Jump = 1;
+		else
+			m_InputData.m_Jump = 0;
+		m_JoystickTapTime = CurTime;
+	}
+
+	m_JoystickRunPressed = RunPressed;
+
+	if( RunPressed )
+	{
+		m_InputDirectionLeft = (RunX <= 0);
+		m_InputDirectionRight = (RunX > 0);
+	}
+
+	// Move 500ms in the same direction, to prevent speed bump when tapping
+	if( !RunPressed && m_JoystickTapTime + time_freq() / 2 > CurTime )
+	{
+		m_InputDirectionLeft = 0;
+		m_InputDirectionRight = 0;
+	}
+
+	if( AimPressed )
+	{
+		m_MousePos = vec2(AimX / 30, AimY / 30);
+		ClampMousePos();
+		m_Hook = 1;
+	}
+	else
+	{
+		m_Hook = 0;
+	}
+
+	m_RelaunchHook = false;
+}
+
+void CControls::TouchscreenInputVolumeKeys(int64 CurTime, bool *FireWasPressed)
+{
+	// Get input from left joystick
+	int RunX = SDL_JoystickGetAxis(m_Joystick, LEFT_JOYSTICK_X);
+	int RunY = SDL_JoystickGetAxis(m_Joystick, LEFT_JOYSTICK_Y);
+	bool RunPressed = (RunX != 0 || RunY != 0);
+	// Get input from right joystick
+	int AimX = SDL_JoystickGetAxis(m_Joystick, RIGHT_JOYSTICK_X);
+	int AimY = SDL_JoystickGetAxis(m_Joystick, RIGHT_JOYSTICK_Y);
+	bool AimPressed = (AimX != 0 || AimY != 0);
+
+	if( m_JoystickRunPressed != RunPressed )
+	{
+		if( RunPressed && RunY < 0 )
+			m_InputData.m_Jump = 1;
+		else
+			m_InputData.m_Jump = 0;
+		m_JoystickTapTime = CurTime;
+	}
+
+	m_JoystickRunPressed = RunPressed;
+
+	if( RunPressed )
+	{
+		m_InputDirectionLeft = (RunX <= 0);
+		m_InputDirectionRight = (RunX > 0);
+	}
+
+	// Move 500ms in the same direction, to prevent speed bump when tapping
+	if( !RunPressed && m_JoystickTapTime + time_freq() / 2 > CurTime )
+	{
+		m_InputDirectionLeft = 0;
+		m_InputDirectionRight = 0;
+	}
+
+	if( AimPressed )
+	{
+		m_MousePos = vec2(AimX / 30, AimY / 30);
+		ClampMousePos();
+	}
+
+	m_RelaunchHook = false;
+
+	if( AimPressed != m_JoystickFirePressed )
+	{
+		// Fire when releasing joystick
+		if( !AimPressed )
+		{
+			if( m_Hook )
+			{
+				m_RelaunchHook = true;
+			}
+			else
+			{
+				m_InputData.m_Fire ++;
+				if( m_InputData.m_Fire % 2 != AimPressed )
+					m_InputData.m_Fire ++;
+				*FireWasPressed = true;
+			}
+		}
+	}
+
+	m_JoystickFirePressed = AimPressed;
+
+	if( !m_Hook )
+	{
+		m_RelaunchHook = false;
+	}
+}
+
+#endif
diff --git a/src/game/client/components/controls.h b/src/game/client/components/controls.h
index aefc850..ef8c89b 100644
--- a/src/game/client/components/controls.h
+++ b/src/game/client/components/controls.h
@@ -3,13 +3,37 @@
 #ifndef GAME_CLIENT_COMPONENTS_CONTROLS_H
 #define GAME_CLIENT_COMPONENTS_CONTROLS_H
 #include <base/vmath.h>
+#include <base/system.h>
 #include <game/client/component.h>
 
+typedef struct _SDL_Joystick SDL_Joystick;
+
 class CControls : public CComponent
 {
+	void TouchscreenInputTwoJoysticks(int64 CurTime, bool *FireWasPressed);
+	void TouchscreenInputThreeJoysticks(int64 CurTime, bool *FireWasPressed);
+	void TouchscreenInputAccelerometer(int64 CurTime, bool *FireWasPressed);
+	void TouchscreenInputDDRace(int64 CurTime, bool *FireWasPressed);
+	void TouchscreenInputVolumeKeys(int64 CurTime, bool *FireWasPressed);
+
 public:
 	vec2 m_MousePos;
 	vec2 m_TargetPos;
+	float m_OldMouseX;
+	float m_OldMouseY;
+	SDL_Joystick *m_Joystick;
+	bool m_JoystickFirePressed;
+	bool m_JoystickRunPressed;
+	int64 m_JoystickTapTime;
+	int m_Hook;
+	bool m_RelaunchHook;
+
+	SDL_Joystick *m_Gamepad;
+	bool m_UsingGamepad;
+
+	SDL_Joystick *m_Accelerometer;
+
+	int m_AmmoCount[NUM_WEAPONS];
 
 	CNetObj_PlayerInput m_InputData;
 	CNetObj_PlayerInput m_LastData;
diff --git a/src/game/client/components/emoticon.cpp b/src/game/client/components/emoticon.cpp
index 9e2a80c..0533617 100644
diff --git a/src/game/client/components/hud.cpp b/src/game/client/components/hud.cpp
index 63ae360..21e5521 100644
diff --git a/src/game/client/components/menus.cpp b/src/game/client/components/menus.cpp
index 111cad6..cd4a299 100644
diff --git a/src/game/client/components/menus.h b/src/game/client/components/menus.h
index 0125278..dc88c1b 100644
diff --git a/src/game/client/components/menus_browser.cpp b/src/game/client/components/menus_browser.cpp
index 42805e0..b88a602 100644
diff --git a/src/game/client/components/menus_demo.cpp b/src/game/client/components/menus_demo.cpp
index 40a9e5b..d4a3247 100644
diff --git a/src/game/client/components/menus_ingame.cpp b/src/game/client/components/menus_ingame.cpp
index 084520d..483527d 100644
diff --git a/src/game/client/components/menus_server.cpp b/src/game/client/components/menus_server.cpp
new file mode 100644
index 0000000..6d19035
diff --git a/src/game/client/components/menus_settings.cpp b/src/game/client/components/menus_settings.cpp
index b2434d9..6944b56 100644
diff --git a/src/game/client/components/spectator.cpp b/src/game/client/components/spectator.cpp
index c09b2ee..95bacfc 100644
diff --git a/src/game/client/gameclient.cpp b/src/game/client/gameclient.cpp
index 77187b5..5d7086d 100644
diff --git a/src/game/client/ui.cpp b/src/game/client/ui.cpp
index c521957..99a08a5 100644
diff --git a/src/game/client/ui.h b/src/game/client/ui.h
index daba5d5..3784974 100644
diff --git a/src/game/variables.h b/src/game/variables.h
index 1cc329a..b1b02a9 100644
--- a/src/game/variables.h
+++ b/src/game/variables.h
@@ -11,7 +11,11 @@ MACRO_CONFIG_INT(ClNameplates, cl_nameplates, 1, 0, 1, CFGFLAG_CLIENT|CFGFLAG_SA
 MACRO_CONFIG_INT(ClNameplatesAlways, cl_nameplates_always, 1, 0, 1, CFGFLAG_CLIENT|CFGFLAG_SAVE, "Always show name plates disregarding of distance")
 MACRO_CONFIG_INT(ClNameplatesTeamcolors, cl_nameplates_teamcolors, 1, 0, 1, CFGFLAG_CLIENT|CFGFLAG_SAVE, "Use team colors for name plates")
 MACRO_CONFIG_INT(ClNameplatesSize, cl_nameplates_size, 50, 0, 100, CFGFLAG_CLIENT|CFGFLAG_SAVE, "Size of the name plates from 0 to 100%")
-MACRO_CONFIG_INT(ClAutoswitchWeapons, cl_autoswitch_weapons, 0, 0, 1, CFGFLAG_CLIENT|CFGFLAG_SAVE, "Auto switch weapon on pickup")
+MACRO_CONFIG_INT(ClAutoswitchWeapons, cl_autoswitch_weapons, 1, 0, 1, CFGFLAG_CLIENT|CFGFLAG_SAVE, "Auto switch weapon on pickup")
+MACRO_CONFIG_INT(ClAutoswitchWeaponsOutOfAmmo, cl_autoswitch_weapons_out_of_ammo, 1, 0, 1, CFGFLAG_CLIENT|CFGFLAG_SAVE, "Auto switch weapon when out of ammo")
+
+MACRO_CONFIG_INT(ClTouchscreenMode, cl_touchscreen_mode_2, TOUCHSCREEN_ACCELEROMETER, TOUCHSCREEN_TWO_JOYSTICKS, TOUCHSCREEN_VOLUME_KEYS, CFGFLAG_CLIENT|CFGFLAG_SAVE, "Touchscreen controls preset")
+MACRO_CONFIG_INT(ClAccelerometerSensitivity, cl_accelerometer_sensitivity, 2000, 0, 10000, CFGFLAG_CLIENT|CFGFLAG_SAVE, "Accelerometer sensitivity")
 
 MACRO_CONFIG_INT(ClShowhud, cl_showhud, 1, 0, 1, CFGFLAG_CLIENT|CFGFLAG_SAVE, "Show ingame HUD")
 MACRO_CONFIG_INT(ClShowChatFriends, cl_show_chat_friends, 0, 0, 1, CFGFLAG_CLIENT|CFGFLAG_SAVE, "Show only chat messages from friends")
@@ -22,9 +26,9 @@ MACRO_CONFIG_INT(ClThreadsoundloading, cl_threadsoundloading, 0, 0, 1, CFGFLAG_C
 
 MACRO_CONFIG_INT(ClWarningTeambalance, cl_warning_teambalance, 1, 0, 1, CFGFLAG_CLIENT|CFGFLAG_SAVE, "Warn about team balance")
 
-MACRO_CONFIG_INT(ClMouseDeadzone, cl_mouse_deadzone, 300, 0, 0, CFGFLAG_CLIENT|CFGFLAG_SAVE, "")
+MACRO_CONFIG_INT(ClMouseDeadzone, cl_mouse_deadzone, 800, 0, 0, CFGFLAG_CLIENT|CFGFLAG_SAVE, "") // Disable dynamic camera on Android, screen becomes jerky when you tap joystick
 MACRO_CONFIG_INT(ClMouseFollowfactor, cl_mouse_followfactor, 60, 0, 200, CFGFLAG_CLIENT|CFGFLAG_SAVE, "")
-MACRO_CONFIG_INT(ClMouseMaxDistance, cl_mouse_max_distance, 800, 0, 0, CFGFLAG_CLIENT|CFGFLAG_SAVE, "")
+MACRO_CONFIG_INT(ClMouseMaxDistance, cl_mouse_max_distance, 400, 0, 0, CFGFLAG_CLIENT|CFGFLAG_SAVE, "") // Prevent crosshair from moving out of screen on Android
 
 MACRO_CONFIG_INT(EdShowkeys, ed_showkeys, 0, 0, 1, CFGFLAG_CLIENT|CFGFLAG_SAVE, "")
 
