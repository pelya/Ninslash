diff --git a/bin-armeabi-v7a/busybox b/bin-armeabi-v7a/busybox
new file mode 100755
index 0000000..e69f7df
Binary files /dev/null and b/bin-armeabi-v7a/busybox differ
diff --git a/bin-armeabi-v7a/teebot b/bin-armeabi-v7a/teebot
new file mode 100755
index 0000000..76a74e0
Binary files /dev/null and b/bin-armeabi-v7a/teebot differ
diff --git a/bin-mips/busybox b/bin-mips/busybox
new file mode 100755
index 0000000..5e0bd44
Binary files /dev/null and b/bin-mips/busybox differ
diff --git a/bin-mips/teebot b/bin-mips/teebot
new file mode 100755
index 0000000..10ab7e2
Binary files /dev/null and b/bin-mips/teebot differ
diff --git a/bin-x86/busybox b/bin-x86/busybox
new file mode 100755
index 0000000..e7932f9
Binary files /dev/null and b/bin-x86/busybox differ
diff --git a/bin-x86/teebot b/bin-x86/teebot
new file mode 100755
index 0000000..848918d
Binary files /dev/null and b/bin-x86/teebot differ
diff --git a/logo.png b/logo.png
new file mode 100644
index 0000000..f4cb991
Binary files /dev/null and b/logo.png differ
diff --git a/readme.txt b/readme.txt
index db63b8a..b57bfc6 100644
diff --git a/server-config.txt b/server-config.txt
new file mode 100644
index 0000000..d94586a
diff --git a/src/base/detect.h b/src/base/detect.h
index 0e2ef86..10c2fc5 100644
diff --git a/src/base/system.c b/src/base/system.c
index b4bc6fb..cf42764 100644
diff --git a/src/base/tl/algorithm.h b/src/base/tl/algorithm.h
index 6b2e542..27d0db3 100644
diff --git a/src/base/tl/array.h b/src/base/tl/array.h
index 4f4b2fc..7bbe77b 100644
diff --git a/src/base/tl/range.h b/src/base/tl/range.h
index 1d225f4..8f8f23c 100644
diff --git a/src/base/tl/sorted_array.h b/src/base/tl/sorted_array.h
index 7e312e1..72e7d5e 100644
diff --git a/src/base/tl/string.h b/src/base/tl/string.h
index e0b891a..d93f758 100644
diff --git a/src/engine/client/backend_sdl.cpp b/src/engine/client/backend_sdl.cpp
index 37d1019..2ad097e 100644
--- a/src/engine/client/backend_sdl.cpp
+++ b/src/engine/client/backend_sdl.cpp
@@ -1,6 +1,15 @@
 
 #include "SDL.h"
-#include "SDL_opengl.h"
+#if defined(__ANDROID__)
+	#define GL_GLEXT_PROTOTYPES
+	#include <GLES/gl.h>
+	#include <GLES/glext.h>
+	#include <GL/glu.h>
+	#define glOrtho glOrthof
+	#include <SDL_android.h>
+#else
+	#include "SDL_opengl.h"
+#endif
 
 #include <base/tl/threading.h>
 
@@ -249,7 +258,9 @@ void CCommandProcessorFragment_OpenGL::Cmd_Texture_Create(const CCommandBuffer::
 
 	int Oglformat = TexFormatToOpenGLFormat(pCommand->m_Format);
 	int StoreOglformat = TexFormatToOpenGLFormat(pCommand->m_StoreFormat);
-
+#if defined(__ANDROID__)
+	StoreOglformat = Oglformat;
+#else
 	if(pCommand->m_Flags&CCommandBuffer::TEXFLAG_COMPRESSED)
 	{
 		switch(StoreOglformat)
@@ -260,6 +271,7 @@ void CCommandProcessorFragment_OpenGL::Cmd_Texture_Create(const CCommandBuffer::
 			default: StoreOglformat = GL_COMPRESSED_RGBA_ARB;
 		}
 	}
+#endif
 	glGenTextures(1, &m_aTextures[pCommand->m_Slot].m_Tex);
 	glBindTexture(GL_TEXTURE_2D, m_aTextures[pCommand->m_Slot].m_Tex);
 
@@ -309,7 +321,12 @@ void CCommandProcessorFragment_OpenGL::Cmd_Render(const CCommandBuffer::SCommand
 	switch(pCommand->m_PrimType)
 	{
 	case CCommandBuffer::PRIMTYPE_QUADS:
+#if defined(__ANDROID__)
+		for( unsigned i = 0, j = pCommand->m_PrimCount; i < j; i++ )
+			glDrawArrays(GL_TRIANGLE_FAN, i*4, 4);
+#else
 		glDrawArrays(GL_QUADS, 0, pCommand->m_PrimCount*4);
+#endif
 		break;
 	case CCommandBuffer::PRIMTYPE_LINES:
 		glDrawArrays(GL_LINES, 0, pCommand->m_PrimCount*2);
@@ -507,12 +524,16 @@ int CGraphicsBackend_SDL_OpenGL::Init(const char *pName, int *Width, int *Height
 	SDL_EventState(SDL_MOUSEMOTION, SDL_IGNORE); // prevent stuck mouse cursor sdl-bug when loosing fullscreen focus in windows
 
 	// use current resolution as default
+#ifndef __ANDROID__
 	if(*Width == 0 || *Height == 0)
+#endif
 	{
 		*Width = pInfo->current_w;
 		*Height = pInfo->current_h;
 	}
 
+	dbg_msg("gfx", "CGraphicsBackend_SDL_OpenGL::Init(): setting video mode %dx%d", *Width, *Height);
+
 	// set flags
 	int SdlFlags = SDL_OPENGL;
 	if(Flags&IGraphicsBackend::INITFLAG_RESIZABLE)
diff --git a/src/engine/client/backend_sdl.h b/src/engine/client/backend_sdl.h
index e90f945..061e6e7 100644
--- a/src/engine/client/backend_sdl.h
+++ b/src/engine/client/backend_sdl.h
@@ -1,6 +1,5 @@
 
 #include "SDL.h"
-#include "SDL_opengl.h"
 
 #include "graphics_threaded.h"
 
@@ -96,6 +95,44 @@
 
 #elif defined(CONF_FAMILY_UNIX)
 
+#if defined(__ANDROID__)
+
+	#include <EGL/egl.h>
+
+	struct SGLContext
+	{
+		EGLDisplay m_Display;
+		EGLSurface m_SurfaceDraw;
+		EGLSurface m_SurfaceRead;
+		EGLContext m_Context;
+	};
+
+	static SGLContext GL_GetCurrentContext()
+	{
+		SGLContext Context;
+		Context.m_Display = eglGetCurrentDisplay();
+		Context.m_SurfaceDraw = eglGetCurrentSurface(EGL_DRAW);
+		Context.m_SurfaceRead = eglGetCurrentSurface(EGL_READ);
+		Context.m_Context = eglGetCurrentContext();
+		return Context;
+	}
+
+	static void GL_MakeCurrent(const SGLContext &Context)
+	{
+		eglMakeCurrent(Context.m_Display, Context.m_SurfaceDraw, Context.m_SurfaceRead, Context.m_Context);
+	}
+	static void GL_ReleaseContext(const SGLContext &Context)
+	{
+		eglMakeCurrent(Context.m_Display, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT);
+	}
+	static void GL_SwapBuffers(const SGLContext &Context)
+	{
+		// eglSwapBuffers(Context.m_Display, Context.m_SurfaceDraw);
+		SDL_GL_SwapBuffers(); // This will also draw on-screen keyboard
+	}
+
+#else
+
 	#include <GL/glx.h>
 
 	struct SGLContext
@@ -117,6 +154,8 @@
 	static void GL_MakeCurrent(const SGLContext &Context) { glXMakeCurrent(Context.m_pDisplay, Context.m_Drawable, Context.m_Context); }
 	static void GL_ReleaseContext(const SGLContext &Context) { glXMakeCurrent(Context.m_pDisplay, None, 0x0); }
 	static void GL_SwapBuffers(const SGLContext &Context) { glXSwapBuffers(Context.m_pDisplay, Context.m_Drawable); }
+
+#endif
 #else
 	#error missing implementation
 #endif
diff --git a/src/engine/client/client.cpp b/src/engine/client/client.cpp
index b3c5994..efbb3fb 100644
diff --git a/src/engine/client/graphics.cpp b/src/engine/client/graphics.cpp
index 2e8a855..1dbe161 100644
--- a/src/engine/client/graphics.cpp
+++ b/src/engine/client/graphics.cpp
@@ -6,7 +6,15 @@
 #include <base/tl/threading.h>
 
 #include "SDL.h"
-#include "SDL_opengl.h"
+#if defined(__ANDROID__)
+	#define GL_GLEXT_PROTOTYPES
+	#include <GLES/gl.h>
+	#include <GLES/glext.h>
+	#include <GL/glu.h>
+	#define glOrtho glOrthof
+#else
+	#include "SDL_opengl.h"
+#endif
 
 #include <base/system.h>
 #include <engine/external/pnglite/pnglite.h>
@@ -84,7 +92,12 @@ void CGraphics_OpenGL::Flush()
 	if(m_RenderEnable)
 	{
 		if(m_Drawing == DRAWING_QUADS)
+#if defined(__ANDROID__)
+			for( unsigned i = 0, j = m_NumVertices; i < j; i += 4 )
+				glDrawArrays(GL_TRIANGLE_FAN, i, 4);
+#else
 			glDrawArrays(GL_QUADS, 0, m_NumVertices);
+#endif
 		else if(m_Drawing == DRAWING_LINES)
 			glDrawArrays(GL_LINES, 0, m_NumVertices);
 	}
@@ -356,6 +369,9 @@ int CGraphics_OpenGL::LoadTextureRaw(int Width, int Height, int Format, const vo
 		Oglformat = GL_ALPHA;
 
 	// upload texture
+#if defined(__ANDROID__)
+	StoreOglformat = Oglformat;
+#else
 	if(g_Config.m_GfxTextureCompression)
 	{
 		StoreOglformat = GL_COMPRESSED_RGBA_ARB;
@@ -372,6 +388,8 @@ int CGraphics_OpenGL::LoadTextureRaw(int Width, int Height, int Format, const vo
 		else if(StoreFormat == CImageInfo::FORMAT_ALPHA)
 			StoreOglformat = GL_ALPHA;
 	}
+#endif
+
 
 	glGenTextures(1, &m_aTextures[Tex].m_Tex);
 	glBindTexture(GL_TEXTURE_2D, m_aTextures[Tex].m_Tex);
@@ -774,7 +792,9 @@ int CGraphics_SDL::TryInit()
 	SDL_EventState(SDL_MOUSEMOTION, SDL_IGNORE); // prevent stuck mouse cursor sdl-bug when loosing fullscreen focus in windows
 
 	// use current resolution as default
+#ifndef __ANDROID__
 	if(g_Config.m_GfxScreenWidth == 0 || g_Config.m_GfxScreenHeight == 0)
+#endif
 	{
 		g_Config.m_GfxScreenWidth = pInfo->current_w;
 		g_Config.m_GfxScreenHeight = pInfo->current_h;
@@ -783,6 +803,8 @@ int CGraphics_SDL::TryInit()
 	m_ScreenWidth = g_Config.m_GfxScreenWidth;
 	m_ScreenHeight = g_Config.m_GfxScreenHeight;
 
+	dbg_msg("gfx", "CGraphics_SDL::TryInit(): setting video mode %dx%d", m_ScreenWidth, m_ScreenHeight);
+
 	// set flags
 	int Flags = SDL_OPENGL;
 	if(g_Config.m_DbgResizable)
diff --git a/src/engine/client/input.cpp b/src/engine/client/input.cpp
index 7ff8d6f..a91ccd3 100644
diff --git a/src/engine/client/input.h b/src/engine/client/input.h
index 34f880f..528c1e4 100644
diff --git a/src/engine/client/serverbrowser.cpp b/src/engine/client/serverbrowser.cpp
index 9634926..836e666 100644
diff --git a/src/engine/client/sound.cpp b/src/engine/client/sound.cpp
index 343fa2e..60ac7b7 100644
diff --git a/src/engine/input.h b/src/engine/input.h
index 93ceccd..1242b28 100644
diff --git a/src/engine/server/server.cpp b/src/engine/server/server.cpp
index 19745b3..ab0f312 100644
diff --git a/src/engine/shared/config.h b/src/engine/shared/config.h
index c6d8437..611af9e 100644
diff --git a/src/engine/shared/config_variables.h b/src/engine/shared/config_variables.h
index 025a9cf..e202614 100644
diff --git a/src/engine/shared/netban.cpp b/src/engine/shared/netban.cpp
index 707b709..b33b2ea 100644
diff --git a/src/engine/shared/netban.h b/src/engine/shared/netban.h
index 7016483..8d94245 100644
diff --git a/src/engine/shared/network.cpp b/src/engine/shared/network.cpp
index 13d6207..ada4b18 100644
diff --git a/src/engine/shared/network.h b/src/engine/shared/network.h
index b934563..ab193eb 100644
diff --git a/src/engine/shared/network_conn.cpp b/src/engine/shared/network_conn.cpp
index ff88509..6500f51 100644
diff --git a/src/game/client/components/binds.cpp b/src/game/client/components/binds.cpp
index 3feba98..44460b3 100644
--- a/src/game/client/components/binds.cpp
+++ b/src/game/client/components/binds.cpp
@@ -96,12 +96,16 @@ void CBinds::SetDefaults()
 	Bind('d', "+right");
 
 	Bind(KEY_SPACE, "+jump");
+	Bind(KEY_RCTRL, "+fire");
 	Bind(KEY_MOUSE_1, "+fire");
+	Bind(KEY_RETURN, "+hook");
 	Bind(KEY_MOUSE_2, "+hook");
 	Bind(KEY_LSHIFT, "+emote");
 	Bind(KEY_RSHIFT, "+spectate");
-	Bind(KEY_RIGHT, "spectate_next");
-	Bind(KEY_LEFT, "spectate_previous");
+	Bind(KEY_RIGHT, "+right");
+	Bind(KEY_LEFT, "+left");
+	Bind(KEY_UP, "+jump");
+	Bind(KEY_DOWN, "+hook");
 
 	Bind('1', "+weapon1");
 	Bind('2', "+weapon2");
@@ -112,6 +116,9 @@ void CBinds::SetDefaults()
 	Bind(KEY_MOUSE_WHEEL_UP, "+prevweapon");
 	Bind(KEY_MOUSE_WHEEL_DOWN, "+nextweapon");
 
+	Bind(KEY_PAGEUP, "+prevweapon");
+	Bind(KEY_PAGEDOWN, "+nextweapon");
+
 	Bind('t', "chat all");
 	Bind('y', "chat team");
 
diff --git a/src/game/client/components/chat.cpp b/src/game/client/components/chat.cpp
index e7952af..0789e3b 100644
--- a/src/game/client/components/chat.cpp
+++ b/src/game/client/components/chat.cpp
@@ -14,10 +14,13 @@
 
 #include <game/client/components/scoreboard.h>
 #include <game/client/components/sounds.h>
+#include <game/client/components/console.h>
 #include <game/localization.h>
 
 #include "chat.h"
 
+#include <string.h>
+
 
 CChat::CChat()
 {
@@ -99,6 +102,23 @@ void CChat::OnConsoleInit()
 	Console()->Register("+show_chat", "", CFGFLAG_CLIENT, ConShowChat, this, "Show chat");
 }
 
+static char *ListOfRemoteCommands = NULL;
+static void PrintRemoteCommands(const char *Cmd, void *Data)
+{
+	CChat *Chat = (CChat *)Data;
+	char *Str = (char *)mem_alloc(strlen(ListOfRemoteCommands) + strlen(Cmd) + 10, 1);
+	strcpy(Str, ListOfRemoteCommands); // Screw those str_copy ugliness, use stdlib functions
+	strcat(Str, " ");
+	strcat(Str, Cmd);
+	mem_free(ListOfRemoteCommands);
+	ListOfRemoteCommands = Str;
+	if (strlen(ListOfRemoteCommands) >= 100)
+	{
+		Chat->AddLine(-1, 0, ListOfRemoteCommands);
+		strcpy(ListOfRemoteCommands, "");
+	}
+}
+
 bool CChat::OnInput(IInput::CEvent Event)
 {
 	if(m_Mode == MODE_NONE)
@@ -111,6 +131,33 @@ bool CChat::OnInput(IInput::CEvent Event)
 	}
 	else if(Event.m_Flags&IInput::FLAG_PRESS && (Event.m_Key == KEY_RETURN || Event.m_Key == KEY_KP_ENTER))
 	{
+		if(m_Input.GetString()[0] == '!')
+		{
+			if(m_pClient->Client()->RconAuthed())
+			{
+				if(str_comp_num(m_Input.GetString(), "!help", str_length("!help")) == 0)
+				{
+					ListOfRemoteCommands = (char *)mem_alloc(10, 1);
+					strcpy(ListOfRemoteCommands, "");
+					m_pClient->Console()->PossibleCommands(str_length(m_Input.GetString()) > str_length("!help") + 1 ? m_Input.GetString() + str_length("!help") + 1 : "",
+															CFGFLAG_SERVER, true, PrintRemoteCommands, this);
+					if (ListOfRemoteCommands[0])
+						AddLine(-1, 0, ListOfRemoteCommands);
+					mem_free(ListOfRemoteCommands);
+				}
+				else
+					m_pClient->Client()->Rcon(m_Input.GetString() + 1);
+			}
+			else
+			{
+				int idx = 1;
+				if(str_comp_num(m_Input.GetString(), "!password ", str_length("!password ")) == 0)
+					idx = str_length("!password ");
+				m_pClient->Client()->RconAuth("", m_Input.GetString() + idx);
+			}
+			m_Input.Set("");
+		}
+
 		if(m_Input.GetString()[0])
 		{
 			bool AddEntry = false;
@@ -264,6 +311,8 @@ void CChat::EnableMode(int Team)
 		m_Input.Clear();
 		Input()->ClearEvents();
 		m_CompletionChosen = -1;
+
+		UI()->AndroidShowTextInput("");
 	}
 }
 
@@ -398,6 +447,38 @@ void CChat::AddLine(int ClientID, int Team, const char *pLine)
 			m_aLastSoundPlayed[CHAT_CLIENT] = Now;
 		}
 	}
+
+	{
+		// Those wankers cannot even use std::string, stupid bums, so now I have to endure their half-assed string functions and memory management
+		char *msg = (char *)mem_alloc(1, 1);
+		msg[0] = 0;
+		for (int count = 0, line = m_CurrentLine; count < 4; count++, line = (line-1+MAX_LINES)%MAX_LINES)
+		{
+			if (!m_aLines[line].m_aText[0] || !m_aLines[line].m_aName[0])
+				continue;
+			char *msg1 = (char *)mem_alloc(str_length(m_aLines[line].m_aText) + str_length(m_aLines[line].m_aName) + str_length(msg) + 10, 1);
+			str_copy(msg1, m_aLines[line].m_aName, str_length(m_aLines[line].m_aName) + 1);
+			str_copy(msg1 + str_length(msg1), m_aLines[line].m_aText, str_length(m_aLines[line].m_aText) + 1);
+			str_copy(msg1 + str_length(msg1), "\n", 2);
+			str_copy(msg1 + str_length(msg1), msg, str_length(msg) + 1);
+			mem_free(msg);
+			msg = msg1;
+		}
+
+		static const char *RconHelp = "For server console, type !password ServerPassword or !ServerPassword\n";
+		static const char *RconHelpAuthed = "Type server command: !command, !help, or !help part-of-command\n";
+		char *msg1 = (char *)mem_alloc(str_length(RconHelp) + str_length(msg) + 10, 1);
+		if(m_pClient->Client()->RconAuthed())
+			str_copy(msg1, RconHelpAuthed, str_length(RconHelpAuthed) + 1);
+		else
+			str_copy(msg1, RconHelp, str_length(RconHelp) + 1);
+		str_copy(msg1 + str_length(msg1), msg, str_length(msg) + 1);
+		mem_free(msg);
+		msg = msg1;
+
+		UI()->AndroidTextInputHintMessage(msg);
+		mem_free(msg);
+	}
 }
 
 void CChat::OnRender()
@@ -473,12 +554,13 @@ void CChat::OnRender()
 	}
 
 	y -= 8.0f;
+	x += 120.0f;
 
 	int64 Now = time_get();
-	float LineWidth = m_pClient->m_pScoreboard->Active() ? 90.0f : 200.0f;
+	float LineWidth = 240.0f;
 	float HeightLimit = m_pClient->m_pScoreboard->Active() ? 230.0f : m_Show ? 50.0f : 200.0f;
 	float Begin = x;
-	float FontSize = 6.0f;
+	float FontSize = 10.0f;
 	CTextCursor Cursor;
 	int OffsetType = m_pClient->m_pScoreboard->Active() ? 1 : 0;
 	for(int i = 0; i < MAX_LINES; i++)
@@ -538,6 +620,35 @@ void CChat::OnRender()
 	}
 
 	TextRender()->TextColor(1.0f, 1.0f, 1.0f, 1.0f);
+
+	static int deferEvent = 0;
+	if( UI()->AndroidTextInputShown() )
+	{
+		if(m_Mode == MODE_NONE)
+		{
+			deferEvent++;
+			if( deferEvent > 2 )
+				EnableMode(0);
+		}
+		else
+			deferEvent = 0;
+	}
+	else
+	{
+		if(m_Mode != MODE_NONE)
+		{
+			deferEvent++;
+			if( deferEvent > 2 )
+			{
+				IInput::CEvent Event;
+				Event.m_Flags = IInput::FLAG_PRESS;
+				Event.m_Key = KEY_RETURN;
+				OnInput(Event);
+			}
+		}
+		else
+			deferEvent = 0;
+	}
 }
 
 void CChat::Say(int Team, const char *pLine)
diff --git a/src/game/client/components/controls.cpp b/src/game/client/components/controls.cpp
index c079079..64b88bb 100644
--- a/src/game/client/components/controls.cpp
+++ b/src/game/client/components/controls.cpp
@@ -1,5 +1,10 @@
 /* (c) Magnus Auvinen. See licence.txt in the root of the distribution for more information. */
 /* If you are missing that file, acquire a complete release at teeworlds.com.                */
+
+#if defined(__ANDROID__)
+#include <SDL.h>
+#endif
+
 #include <base/math.h>
 
 #include <engine/shared/config.h>
@@ -10,12 +15,42 @@
 #include <game/client/components/chat.h>
 #include <game/client/components/menus.h>
 #include <game/client/components/scoreboard.h>
+#include <engine/graphics.h>
 
 #include "controls.h"
 
+
+enum {	LEFT_JOYSTICK_X = 0, LEFT_JOYSTICK_Y = 1,
+		RIGHT_JOYSTICK_X = 2, RIGHT_JOYSTICK_Y = 3,
+		SECOND_RIGHT_JOYSTICK_X = 20, SECOND_RIGHT_JOYSTICK_Y = 21,
+		ORIENTATION_X = 8, ORIENTATION_Y = 9, ORIENTATION_Z = 10,
+		ACCELEROMETER_X = 0, ACCELEROMETER_Y = 1,
+		NUM_JOYSTICK_AXES = 22 };
+
+
 CControls::CControls()
 {
 	mem_zero(&m_LastData, sizeof(m_LastData));
+
+#if defined(__ANDROID__)
+	SDL_Init(SDL_INIT_JOYSTICK);
+	m_Joystick = SDL_JoystickOpen(0);
+	if( m_Joystick && SDL_JoystickNumAxes(m_Joystick) < NUM_JOYSTICK_AXES )
+	{
+		SDL_JoystickClose(m_Joystick);
+		m_Joystick = NULL;
+	}
+
+	m_Gamepad = SDL_JoystickOpen(2);
+
+	m_Accelerometer = NULL;
+
+	SDL_JoystickEventState(SDL_QUERY);
+
+	m_UsingGamepad = false;
+	if( getenv("OUYA") )
+		m_UsingGamepad = true;
+#endif
 }
 
 void CControls::OnReset()
@@ -31,6 +66,22 @@ void CControls::OnReset()
 
 	m_InputDirectionLeft = 0;
 	m_InputDirectionRight = 0;
+
+	m_JoystickFirePressed = false;
+	m_JoystickRunPressed = false;
+	m_JoystickTapTime = 0;
+	for( int i = 0; i < NUM_WEAPONS; i++ )
+		m_AmmoCount[i] = 0;
+	m_OldMouseX = m_OldMouseY = 0.0f;
+	m_Hook = 0;
+	m_RelaunchHook = false;
+	// Prevent launching hook right after respawning
+	if( g_Config.m_ClTouchscreenMode == TOUCHSCREEN_ACCELEROMETER )
+		m_RelaunchHook = true;
+#if defined(__ANDROID__)
+	if(!m_Accelerometer)
+		m_Accelerometer = SDL_JoystickOpen(1);
+#endif
 }
 
 void CControls::OnRelease()
@@ -41,6 +92,12 @@ void CControls::OnRelease()
 void CControls::OnPlayerDeath()
 {
 	m_LastData.m_WantedWeapon = m_InputData.m_WantedWeapon = 0;
+	for( int i = 0; i < NUM_WEAPONS; i++ )
+		m_AmmoCount[i] = 0;
+
+	// Prevent launching hook right after respawning
+	if( g_Config.m_ClTouchscreenMode == TOUCHSCREEN_ACCELEROMETER )
+		m_RelaunchHook = true;
 }
 
 static void ConKeyInputState(IConsole::IResult *pResult, void *pUserData)
@@ -83,7 +140,7 @@ void CControls::OnConsoleInit()
 	Console()->Register("+left", "", CFGFLAG_CLIENT, ConKeyInputState, &m_InputDirectionLeft, "Move left");
 	Console()->Register("+right", "", CFGFLAG_CLIENT, ConKeyInputState, &m_InputDirectionRight, "Move right");
 	Console()->Register("+jump", "", CFGFLAG_CLIENT, ConKeyInputState, &m_InputData.m_Jump, "Jump");
-	Console()->Register("+hook", "", CFGFLAG_CLIENT, ConKeyInputState, &m_InputData.m_Hook, "Hook");
+	Console()->Register("+hook", "", CFGFLAG_CLIENT, ConKeyInputState, &m_Hook, "Hook");
 	Console()->Register("+fire", "", CFGFLAG_CLIENT, ConKeyInputCounter, &m_InputData.m_Fire, "Fire");
 
 	{ static CInputSet s_Set = {this, &m_InputData.m_WantedWeapon, 1}; Console()->Register("+weapon1", "", CFGFLAG_CLIENT, ConKeyInputSet, (void *)&s_Set, "Switch to hammer"); }
@@ -103,6 +160,8 @@ void CControls::OnMessage(int Msg, void *pRawMsg)
 		CNetMsg_Sv_WeaponPickup *pMsg = (CNetMsg_Sv_WeaponPickup *)pRawMsg;
 		if(g_Config.m_ClAutoswitchWeapons)
 			m_InputData.m_WantedWeapon = pMsg->m_Weapon+1;
+		// We don't really know ammo count, until we'll switch to that weapon, but any non-zero count will suffice here
+		m_AmmoCount[pMsg->m_Weapon%NUM_WEAPONS] = 10;
 	}
 }
 
@@ -156,6 +215,8 @@ int CControls::SnapInput(int *pData)
 		if(!m_InputDirectionLeft && m_InputDirectionRight)
 			m_InputData.m_Direction = 1;
 
+		m_InputData.m_Hook = m_Hook && !m_RelaunchHook;
+
 		// stress testing
 		if(g_Config.m_DbgStress)
 		{
@@ -198,6 +259,99 @@ int CControls::SnapInput(int *pData)
 
 void CControls::OnRender()
 {
+#if defined(__ANDROID__)
+	int64 CurTime = time_get();
+	bool FireWasPressed = false;
+
+	if( m_Joystick && !m_UsingGamepad )
+	{
+		switch( g_Config.m_ClTouchscreenMode )
+		{
+			case TOUCHSCREEN_TWO_JOYSTICKS:
+				TouchscreenInputTwoJoysticks(CurTime, &FireWasPressed);
+				break;
+			case TOUCHSCREEN_THREE_JOYSTICKS:
+				TouchscreenInputThreeJoysticks(CurTime, &FireWasPressed);
+				break;
+			case TOUCHSCREEN_ACCELEROMETER:
+				TouchscreenInputAccelerometer(CurTime, &FireWasPressed);
+				break;
+			case TOUCHSCREEN_DDRACE:
+				TouchscreenInputDDRace(CurTime, &FireWasPressed);
+				break;
+			case TOUCHSCREEN_VOLUME_KEYS:
+				TouchscreenInputVolumeKeys(CurTime, &FireWasPressed);
+				break;
+		}
+	}
+
+	if( m_Gamepad )
+	{
+		enum {
+			GAMEPAD_DEAD_ZONE = 65536 / 8,
+		};
+
+		// Get input from left joystick
+		int RunX = SDL_JoystickGetAxis(m_Gamepad, LEFT_JOYSTICK_X);
+		int RunY = SDL_JoystickGetAxis(m_Gamepad, LEFT_JOYSTICK_Y);
+		if( m_UsingGamepad )
+		{
+			//m_InputDirectionLeft = (RunX < -GAMEPAD_DEAD_ZONE);
+			//m_InputDirectionRight = (RunX > GAMEPAD_DEAD_ZONE);
+			static int OldRunX = 0, OldRunY = 0;
+			if( RunX < -GAMEPAD_DEAD_ZONE && OldRunX >= -GAMEPAD_DEAD_ZONE )
+				m_InputDirectionLeft = 1;
+			if( RunX >= -GAMEPAD_DEAD_ZONE && OldRunX < -GAMEPAD_DEAD_ZONE )
+				m_InputDirectionLeft = 0;
+			if( RunX > GAMEPAD_DEAD_ZONE && OldRunX <= GAMEPAD_DEAD_ZONE )
+				m_InputDirectionRight = 1;
+			if( RunX <= GAMEPAD_DEAD_ZONE && OldRunX > GAMEPAD_DEAD_ZONE )
+				m_InputDirectionRight = 0;
+			OldRunX = RunX;
+			OldRunY = RunY;
+		}
+
+		// Get input from right joystick
+		int AimX = SDL_JoystickGetAxis(m_Gamepad, RIGHT_JOYSTICK_X);
+		int AimY = SDL_JoystickGetAxis(m_Gamepad, RIGHT_JOYSTICK_Y);
+		if( abs(AimX) > GAMEPAD_DEAD_ZONE || abs(AimY) > GAMEPAD_DEAD_ZONE )
+		{
+			m_MousePos = vec2(AimX / 30, AimY / 30);
+			ClampMousePos();
+		}
+
+		if( !m_UsingGamepad && (abs(AimX) > GAMEPAD_DEAD_ZONE || abs(AimY) > GAMEPAD_DEAD_ZONE ||
+			abs(RunX) > GAMEPAD_DEAD_ZONE || abs(RunY) > GAMEPAD_DEAD_ZONE) || SDL_GetMouseState(NULL, NULL) & SDL_BUTTON(SDL_BUTTON_RIGHT) )
+		{
+			UI()->AndroidShowScreenKeys(false);
+			m_UsingGamepad = true;
+		}
+	}
+
+	if( g_Config.m_ClAutoswitchWeaponsOutOfAmmo && m_pClient->m_Snap.m_pLocalCharacter )
+	{
+		// Keep track of ammo count, we know weapon ammo only when we switch to that weapon, this is tracked on server and protocol does not track that
+		m_AmmoCount[m_pClient->m_Snap.m_pLocalCharacter->m_Weapon%NUM_WEAPONS] = m_pClient->m_Snap.m_pLocalCharacter->m_AmmoCount;
+		// Autoswitch weapon if we're out of ammo
+		if( (m_InputData.m_Fire % 2 != 0 || FireWasPressed) &&
+			m_pClient->m_Snap.m_pLocalCharacter->m_AmmoCount == 0 &&
+			m_pClient->m_Snap.m_pLocalCharacter->m_Weapon != WEAPON_HAMMER &&
+			m_pClient->m_Snap.m_pLocalCharacter->m_Weapon != WEAPON_NINJA )
+		{
+			int w;
+			for( w = WEAPON_RIFLE; w > WEAPON_GUN; w-- )
+			{
+				if( w == m_pClient->m_Snap.m_pLocalCharacter->m_Weapon )
+					continue;
+				if( m_AmmoCount[w] > 0 )
+					break;
+			}
+			if( w != m_pClient->m_Snap.m_pLocalCharacter->m_Weapon )
+				m_InputData.m_WantedWeapon = w+1;
+		}
+	}
+#endif
+
 	// update target pos
 	if(m_pClient->m_Snap.m_pGameInfoObj && !m_pClient->m_Snap.m_SpecInfo.m_Active)
 		m_TargetPos = m_pClient->m_LocalCharacterPos + m_MousePos;
@@ -213,8 +367,20 @@ bool CControls::OnMouseMove(float x, float y)
 		(m_pClient->m_Snap.m_SpecInfo.m_Active && m_pClient->m_pChat->IsActive()))
 		return false;
 
+#if defined(__ANDROID__) // No relative mouse on Android
+	// We're using joystick on Android, mouse is disabled
+
+	if( m_OldMouseX != x || m_OldMouseY != y )
+	{
+		m_OldMouseX = x;
+		m_OldMouseY = y;
+		m_MousePos = vec2((x - g_Config.m_GfxScreenWidth/2), (y - g_Config.m_GfxScreenHeight/2));
+		ClampMousePos();
+	}
+#else
 	m_MousePos += vec2(x, y); // TODO: ugly
 	ClampMousePos();
+#endif
 
 	return true;
 }
@@ -225,7 +391,6 @@ void CControls::ClampMousePos()
 	{
 		m_MousePos.x = clamp(m_MousePos.x, 200.0f, Collision()->GetWidth()*32-200.0f);
 		m_MousePos.y = clamp(m_MousePos.y, 200.0f, Collision()->GetHeight()*32-200.0f);
-
 	}
 	else
 	{
@@ -237,3 +402,287 @@ void CControls::ClampMousePos()
 			m_MousePos = normalize(m_MousePos)*MouseMax;
 	}
 }
+
+#if defined(__ANDROID__)
+void CControls::TouchscreenInputTwoJoysticks(int64 CurTime, bool *FireWasPressed)
+{
+	// Get input from left joystick
+	int RunX = SDL_JoystickGetAxis(m_Joystick, LEFT_JOYSTICK_X);
+	int RunY = SDL_JoystickGetAxis(m_Joystick, LEFT_JOYSTICK_Y);
+	bool RunPressed = (RunX != 0 || RunY != 0);
+	// Get input from right joystick
+	int AimX = SDL_JoystickGetAxis(m_Joystick, RIGHT_JOYSTICK_X);
+	int AimY = SDL_JoystickGetAxis(m_Joystick, RIGHT_JOYSTICK_Y);
+	bool AimPressed = (AimX != 0 || AimY != 0);
+
+	if( m_JoystickRunPressed != RunPressed )
+	{
+		if( RunPressed && RunY < 0 )
+			m_InputData.m_Jump = 1;
+		else
+			m_InputData.m_Jump = 0;
+		m_JoystickTapTime = CurTime;
+	}
+
+	m_JoystickRunPressed = RunPressed;
+
+	if( RunPressed )
+	{
+		m_InputDirectionLeft = (RunX <= 0);
+		m_InputDirectionRight = (RunX > 0);
+	}
+
+	// Move 500ms in the same direction, to prevent speed bump when tapping
+	if( !RunPressed && m_JoystickTapTime + time_freq() / 2 > CurTime )
+	{
+		m_InputDirectionLeft = 0;
+		m_InputDirectionRight = 0;
+	}
+
+	if( AimPressed )
+	{
+		m_MousePos = vec2(AimX / 30, AimY / 30);
+		ClampMousePos();
+	}
+
+	m_RelaunchHook = false;
+}
+
+void CControls::TouchscreenInputThreeJoysticks(int64 CurTime, bool *FireWasPressed)
+{
+	// Get input from left joystick
+	int RunX = SDL_JoystickGetAxis(m_Joystick, LEFT_JOYSTICK_X);
+	int RunY = SDL_JoystickGetAxis(m_Joystick, LEFT_JOYSTICK_Y);
+	bool RunPressed = (RunX != 0 || RunY != 0);
+	// Get input from right joystick
+	int AimX = SDL_JoystickGetAxis(m_Joystick, RIGHT_JOYSTICK_X);
+	int AimY = SDL_JoystickGetAxis(m_Joystick, RIGHT_JOYSTICK_Y);
+	bool AimPressed = (AimX != 0 || AimY != 0);
+	// Get input from another right joystick
+	int HookX = SDL_JoystickGetAxis(m_Joystick, SECOND_RIGHT_JOYSTICK_X);
+	int HookY = SDL_JoystickGetAxis(m_Joystick, SECOND_RIGHT_JOYSTICK_Y);
+	bool HookPressed = (HookX != 0 || HookY != 0);
+
+	if( m_JoystickRunPressed != RunPressed )
+	{
+		if( RunPressed && RunY < 0 )
+			m_InputData.m_Jump = 1;
+		else
+			m_InputData.m_Jump = 0;
+		m_JoystickTapTime = CurTime;
+	}
+
+	m_JoystickRunPressed = RunPressed;
+
+	if( RunPressed )
+	{
+		m_InputDirectionLeft = (RunX <= 0);
+		m_InputDirectionRight = (RunX > 0);
+	}
+
+	// Move 500ms in the same direction, to prevent speed bump when tapping
+	if( !RunPressed && m_JoystickTapTime + time_freq() / 2 > CurTime )
+	{
+		m_InputDirectionLeft = 0;
+		m_InputDirectionRight = 0;
+	}
+
+	if( HookPressed )
+	{
+		m_MousePos = vec2(HookX / 30, HookY / 30);
+		ClampMousePos();
+		m_Hook = 1;
+	}
+	else
+	{
+		m_Hook = 0;
+	}
+
+	if( AimPressed )
+	{
+		m_MousePos = vec2(AimX / 30, AimY / 30);
+		ClampMousePos();
+	}
+
+	if( AimPressed != m_JoystickFirePressed )
+	{
+		// Fire when releasing joystick
+		if( !AimPressed )
+		{
+			m_InputData.m_Fire ++;
+			if( m_InputData.m_Fire % 2 != AimPressed )
+				m_InputData.m_Fire ++;
+			*FireWasPressed = true;
+		}
+	}
+
+	m_JoystickFirePressed = AimPressed;
+	m_RelaunchHook = false;
+}
+
+void CControls::TouchscreenInputAccelerometer(int64 CurTime, bool *FireWasPressed)
+{
+	int X = 0, Y = 0;
+	static int OldX = 0;
+
+	if( m_Accelerometer != NULL )
+	{
+		X = SDL_JoystickGetAxis(m_Accelerometer, ACCELEROMETER_X);
+		Y = SDL_JoystickGetAxis(m_Accelerometer, ACCELEROMETER_Y);
+	}
+
+	if( X >= g_Config.m_ClAccelerometerSensitivity && OldX < g_Config.m_ClAccelerometerSensitivity )
+		m_InputDirectionRight = 1;
+	if( X < g_Config.m_ClAccelerometerSensitivity && OldX >= g_Config.m_ClAccelerometerSensitivity )
+		m_InputDirectionRight = 0;
+	if( X <= -g_Config.m_ClAccelerometerSensitivity && OldX > -g_Config.m_ClAccelerometerSensitivity )
+		m_InputDirectionLeft = 1;
+	if( X > -g_Config.m_ClAccelerometerSensitivity && OldX <= -g_Config.m_ClAccelerometerSensitivity )
+		m_InputDirectionLeft = 0;
+
+	OldX = X;
+
+	// Get input from right joystick
+	int AimX = SDL_JoystickGetAxis(m_Joystick, LEFT_JOYSTICK_X);
+	int AimY = SDL_JoystickGetAxis(m_Joystick, LEFT_JOYSTICK_Y);
+	bool AimPressed = (AimX != 0 || AimY != 0);
+	static int OldAimX = 0, OldAimY = 0;
+	bool OldAimPressed = (OldAimX != 0 || OldAimY != 0);
+
+	if( AimPressed )
+	{
+		m_MousePos = vec2(AimX / 30, AimY / 30);
+		ClampMousePos();
+		m_Hook = 0;
+		if( !OldAimPressed )
+			m_RelaunchHook = false;
+	}
+	else
+	{
+		if (m_InputData.m_Fire % 2 == 0)
+			m_Hook = 1;
+	}
+	OldAimX = AimX;
+	OldAimY = AimY;
+}
+
+void CControls::TouchscreenInputDDRace(int64 CurTime, bool *FireWasPressed)
+{
+	// Get input from left joystick
+	int RunX = SDL_JoystickGetAxis(m_Joystick, LEFT_JOYSTICK_X);
+	int RunY = SDL_JoystickGetAxis(m_Joystick, LEFT_JOYSTICK_Y);
+	bool RunPressed = (RunX != 0 || RunY != 0);
+	// Get input from right joystick
+	int AimX = SDL_JoystickGetAxis(m_Joystick, RIGHT_JOYSTICK_X);
+	int AimY = SDL_JoystickGetAxis(m_Joystick, RIGHT_JOYSTICK_Y);
+	bool AimPressed = (AimX != 0 || AimY != 0);
+
+	if( m_JoystickRunPressed != RunPressed )
+	{
+		if( RunPressed && RunY < 0 )
+			m_InputData.m_Jump = 1;
+		else
+			m_InputData.m_Jump = 0;
+		m_JoystickTapTime = CurTime;
+	}
+
+	m_JoystickRunPressed = RunPressed;
+
+	if( RunPressed )
+	{
+		m_InputDirectionLeft = (RunX <= 0);
+		m_InputDirectionRight = (RunX > 0);
+	}
+
+	// Move 500ms in the same direction, to prevent speed bump when tapping
+	if( !RunPressed && m_JoystickTapTime + time_freq() / 2 > CurTime )
+	{
+		m_InputDirectionLeft = 0;
+		m_InputDirectionRight = 0;
+	}
+
+	if( AimPressed )
+	{
+		m_MousePos = vec2(AimX / 30, AimY / 30);
+		ClampMousePos();
+		m_Hook = 1;
+	}
+	else
+	{
+		m_Hook = 0;
+	}
+
+	m_RelaunchHook = false;
+}
+
+void CControls::TouchscreenInputVolumeKeys(int64 CurTime, bool *FireWasPressed)
+{
+	// Get input from left joystick
+	int RunX = SDL_JoystickGetAxis(m_Joystick, LEFT_JOYSTICK_X);
+	int RunY = SDL_JoystickGetAxis(m_Joystick, LEFT_JOYSTICK_Y);
+	bool RunPressed = (RunX != 0 || RunY != 0);
+	// Get input from right joystick
+	int AimX = SDL_JoystickGetAxis(m_Joystick, RIGHT_JOYSTICK_X);
+	int AimY = SDL_JoystickGetAxis(m_Joystick, RIGHT_JOYSTICK_Y);
+	bool AimPressed = (AimX != 0 || AimY != 0);
+
+	if( m_JoystickRunPressed != RunPressed )
+	{
+		if( RunPressed && RunY < 0 )
+			m_InputData.m_Jump = 1;
+		else
+			m_InputData.m_Jump = 0;
+		m_JoystickTapTime = CurTime;
+	}
+
+	m_JoystickRunPressed = RunPressed;
+
+	if( RunPressed )
+	{
+		m_InputDirectionLeft = (RunX <= 0);
+		m_InputDirectionRight = (RunX > 0);
+	}
+
+	// Move 500ms in the same direction, to prevent speed bump when tapping
+	if( !RunPressed && m_JoystickTapTime + time_freq() / 2 > CurTime )
+	{
+		m_InputDirectionLeft = 0;
+		m_InputDirectionRight = 0;
+	}
+
+	if( AimPressed )
+	{
+		m_MousePos = vec2(AimX / 30, AimY / 30);
+		ClampMousePos();
+	}
+
+	m_RelaunchHook = false;
+
+	if( AimPressed != m_JoystickFirePressed )
+	{
+		// Fire when releasing joystick
+		if( !AimPressed )
+		{
+			if( m_Hook )
+			{
+				m_RelaunchHook = true;
+			}
+			else
+			{
+				m_InputData.m_Fire ++;
+				if( m_InputData.m_Fire % 2 != AimPressed )
+					m_InputData.m_Fire ++;
+				*FireWasPressed = true;
+			}
+		}
+	}
+
+	m_JoystickFirePressed = AimPressed;
+
+	if( !m_Hook )
+	{
+		m_RelaunchHook = false;
+	}
+}
+
+#endif
diff --git a/src/game/client/components/controls.h b/src/game/client/components/controls.h
index aefc850..ef8c89b 100644
--- a/src/game/client/components/controls.h
+++ b/src/game/client/components/controls.h
@@ -3,13 +3,37 @@
 #ifndef GAME_CLIENT_COMPONENTS_CONTROLS_H
 #define GAME_CLIENT_COMPONENTS_CONTROLS_H
 #include <base/vmath.h>
+#include <base/system.h>
 #include <game/client/component.h>
 
+typedef struct _SDL_Joystick SDL_Joystick;
+
 class CControls : public CComponent
 {
+	void TouchscreenInputTwoJoysticks(int64 CurTime, bool *FireWasPressed);
+	void TouchscreenInputThreeJoysticks(int64 CurTime, bool *FireWasPressed);
+	void TouchscreenInputAccelerometer(int64 CurTime, bool *FireWasPressed);
+	void TouchscreenInputDDRace(int64 CurTime, bool *FireWasPressed);
+	void TouchscreenInputVolumeKeys(int64 CurTime, bool *FireWasPressed);
+
 public:
 	vec2 m_MousePos;
 	vec2 m_TargetPos;
+	float m_OldMouseX;
+	float m_OldMouseY;
+	SDL_Joystick *m_Joystick;
+	bool m_JoystickFirePressed;
+	bool m_JoystickRunPressed;
+	int64 m_JoystickTapTime;
+	int m_Hook;
+	bool m_RelaunchHook;
+
+	SDL_Joystick *m_Gamepad;
+	bool m_UsingGamepad;
+
+	SDL_Joystick *m_Accelerometer;
+
+	int m_AmmoCount[NUM_WEAPONS];
 
 	CNetObj_PlayerInput m_InputData;
 	CNetObj_PlayerInput m_LastData;
diff --git a/src/game/client/components/emoticon.cpp b/src/game/client/components/emoticon.cpp
index 9e2a80c..0533617 100644
--- a/src/game/client/components/emoticon.cpp
+++ b/src/game/client/components/emoticon.cpp
@@ -54,8 +54,13 @@ bool CEmoticon::OnMouseMove(float x, float y)
 	if(!m_Active)
 		return false;
 
+#if defined(__ANDROID__) // No relative mouse on Android
+	m_SelectorMouse = vec2(x,y);
+#else
 	UI()->ConvertMouseMove(&x, &y);
 	m_SelectorMouse += vec2(x,y);
+#endif
+
 	return true;
 }
 
diff --git a/src/game/client/components/hud.cpp b/src/game/client/components/hud.cpp
index 63ae360..21e5521 100644
--- a/src/game/client/components/hud.cpp
+++ b/src/game/client/components/hud.cpp
@@ -326,10 +326,19 @@ void CHud::RenderVoting()
 	if(!m_pClient->m_pVoting->IsVoting() || Client()->State() == IClient::STATE_DEMOPLAYBACK)
 		return;
 
+	static const float TextX = 130;
+	static const float TextY = 1;
+	static const float TextW = 200;
+	static const float TextH = 42;
+
 	Graphics()->TextureSet(-1);
 	Graphics()->QuadsBegin();
 	Graphics()->SetColor(0,0,0,0.40f);
-	RenderTools()->DrawRoundRect(-10, 60-2, 100+10+4+5, 46, 5.0f);
+	RenderTools()->DrawRoundRect(TextX-5, TextY, TextW+15, TextH, 5.0f);
+#if defined(__ANDROID__)
+	RenderTools()->DrawRoundRect(TextX-5, TextY+TextH+2, TextW/2-10, 30, 5.0f);
+	RenderTools()->DrawRoundRect(TextX+TextW/2+20, TextY+TextH+2, TextW/2-10, 30, 5.0f);
+#endif
 	Graphics()->QuadsEnd();
 
 	TextRender()->TextColor(1,1,1,1);
@@ -337,24 +346,25 @@ void CHud::RenderVoting()
 	CTextCursor Cursor;
 	char aBuf[512];
 	str_format(aBuf, sizeof(aBuf), Localize("%ds left"), m_pClient->m_pVoting->SecondsLeft());
-	float tw = TextRender()->TextWidth(0x0, 6, aBuf, -1);
-	TextRender()->SetCursor(&Cursor, 5.0f+100.0f-tw, 60.0f, 6.0f, TEXTFLAG_RENDER);
+	float tw = TextRender()->TextWidth(0x0, 10, aBuf, -1);
+	TextRender()->SetCursor(&Cursor, TextX+TextW-tw, 0.0f, 10.0f, TEXTFLAG_RENDER);
 	TextRender()->TextEx(&Cursor, aBuf, -1);
 
-	TextRender()->SetCursor(&Cursor, 5.0f, 60.0f, 6.0f, TEXTFLAG_RENDER);
-	Cursor.m_LineWidth = 100.0f-tw;
+	TextRender()->SetCursor(&Cursor, TextX, 0.0f, 10.0f, TEXTFLAG_RENDER);
+	Cursor.m_LineWidth = TextW-tw;
 	Cursor.m_MaxLines = 3;
 	TextRender()->TextEx(&Cursor, m_pClient->m_pVoting->VoteDescription(), -1);
 
 	// reason
 	str_format(aBuf, sizeof(aBuf), "%s %s", Localize("Reason:"), m_pClient->m_pVoting->VoteReason());
-	TextRender()->SetCursor(&Cursor, 5.0f, 79.0f, 6.0f, TEXTFLAG_RENDER|TEXTFLAG_STOP_AT_END);
-	Cursor.m_LineWidth = 100.0f;
+	TextRender()->SetCursor(&Cursor, TextX, 23.0f, 10.0f, TEXTFLAG_RENDER|TEXTFLAG_STOP_AT_END);
+	Cursor.m_LineWidth = TextW;
 	TextRender()->TextEx(&Cursor, aBuf, -1);
 
-	CUIRect Base = {5, 88, 100, 4};
+	CUIRect Base = {TextX, TextH - 8, TextW, 4};
 	m_pClient->m_pVoting->RenderBars(Base, false);
 
+#if !defined(__ANDROID__)
 	const char *pYesKey = m_pClient->m_pBinds->GetKey("vote yes");
 	const char *pNoKey = m_pClient->m_pBinds->GetKey("vote no");
 	str_format(aBuf, sizeof(aBuf), "%s - %s", pYesKey, Localize("Vote yes"));
@@ -363,6 +373,24 @@ void CHud::RenderVoting()
 
 	str_format(aBuf, sizeof(aBuf), "%s - %s", Localize("Vote no"), pNoKey);
 	UI()->DoLabel(&Base, aBuf, 6.0f, 1);
+#else
+	Base.y += Base.h+15;
+	UI()->DoLabel(&Base, Localize("Vote yes"), 16.0f, -1);
+	UI()->DoLabel(&Base, Localize("Vote no"), 16.0f, 1);
+	if( Input()->KeyDown(KEY_MOUSE_1) )
+	{
+		float mx, my;
+		Input()->MouseRelative(&mx, &my);
+		mx = mx * m_Width / Graphics()->ScreenWidth();
+		my = my * m_Height / Graphics()->ScreenHeight();
+		if( my > TextY+TextH-10 && my < TextY+TextH+30 ) {
+			if( mx > TextX-5 && mx < TextX-5+TextW/2-10 )
+				m_pClient->m_pVoting->Vote(1);
+			if( mx > TextX+TextW/2+20 && mx < TextX+TextW/2+20+TextW/2-10 )
+				m_pClient->m_pVoting->Vote(-1);
+		}
+	}
+#endif
 }
 
 void CHud::RenderCursor()
diff --git a/src/game/client/components/menus.cpp b/src/game/client/components/menus.cpp
index 111cad6..cd4a299 100644
--- a/src/game/client/components/menus.cpp
+++ b/src/game/client/components/menus.cpp
@@ -30,6 +30,7 @@
 #include "countryflags.h"
 #include "menus.h"
 #include "skins.h"
+#include "controls.h"
 
 vec4 CMenus::ms_GuiColor;
 vec4 CMenus::ms_ColorTabbarInactiveOutgame;
@@ -39,8 +40,9 @@ vec4 CMenus::ms_ColorTabbarActive = vec4(0,0,0,0.5f);
 vec4 CMenus::ms_ColorTabbarInactiveIngame;
 vec4 CMenus::ms_ColorTabbarActiveIngame;
 
-float CMenus::ms_ButtonHeight = 25.0f;
-float CMenus::ms_ListheaderHeight = 17.0f;
+float CMenus::ms_ButtonHeight = 50.0f;
+float CMenus::ms_ListheaderHeight = 50.0f;
+float CMenus::ms_ListitemAdditionalHeight = 33.0f;
 float CMenus::ms_FontmodHeight = 0.8f;
 
 IInput::CEvent CMenus::m_aInputEvents[MAX_INPUTEVENTS];
@@ -70,6 +72,7 @@ CMenus::CMenus()
 	m_aCallvoteReason[0] = 0;
 
 	m_FriendlistSelectedIndex = -1;
+	m_DoubleClickIndex = -1;
 }
 
 vec4 CMenus::ButtonColorMul(const void *pID)
@@ -119,7 +122,9 @@ int CMenus::DoButton_Menu(const void *pID, const char *pText, int Checked, const
 	RenderTools()->DrawUIRect(pRect, vec4(1,1,1,0.5f)*ButtonColorMul(pID), CUI::CORNER_ALL, 5.0f);
 	CUIRect Temp;
 	pRect->HMargin(pRect->h>=20.0f?2.0f:1.0f, &Temp);
-	UI()->DoLabel(&Temp, pText, Temp.h*ms_FontmodHeight, 0);
+	float TextH = min(22.0f, Temp.h);
+	Temp.y += (Temp.h - TextH) / 2;
+	UI()->DoLabel(&Temp, pText, TextH*ms_FontmodHeight, 0);
 	return UI()->DoButtonLogic(pID, pText, Checked, pRect);
 }
 
@@ -139,7 +144,9 @@ int CMenus::DoButton_MenuTab(const void *pID, const char *pText, int Checked, co
 		RenderTools()->DrawUIRect(pRect, ms_ColorTabbarInactive, Corners, 10.0f);
 	CUIRect Temp;
 	pRect->HMargin(2.0f, &Temp);
-	UI()->DoLabel(&Temp, pText, Temp.h*ms_FontmodHeight, 0);
+	float TextH = min(22.0f, Temp.h);
+	Temp.y += (Temp.h - TextH) / 2;
+	UI()->DoLabel(&Temp, pText, TextH*ms_FontmodHeight, 0);
 
 	return UI()->DoButtonLogic(pID, pText, Checked, pRect);
 }
@@ -151,7 +158,8 @@ int CMenus::DoButton_GridHeader(const void *pID, const char *pText, int Checked,
 		RenderTools()->DrawUIRect(pRect, vec4(1,1,1,0.5f), CUI::CORNER_T, 5.0f);
 	CUIRect t;
 	pRect->VSplitLeft(5.0f, 0, &t);
-	UI()->DoLabel(&t, pText, pRect->h*ms_FontmodHeight, -1);
+	float TextH = min(20.0f, pRect->h);
+	UI()->DoLabel(&t, pText, TextH*ms_FontmodHeight, -1);
 	return UI()->DoButtonLogic(pID, pText, Checked, pRect);
 }
 
@@ -270,7 +278,14 @@ int CMenus::DoEditBox(void *pID, const CUIRect *pRect, char *pStr, unsigned StrS
 	}
 
 	if(Inside)
+	{
 		UI()->SetHotItem(pID);
+		if(UI()->ActiveItem() == pID && UI()->MouseButtonClicked(0))
+		{
+			s_AtIndex = 0;
+			UI()->AndroidBlockAndGetTextInput(pStr, StrSize, "");
+		}
+	}
 
 	CUIRect Textbox = *pRect;
 	RenderTools()->DrawUIRect(&Textbox, vec4(1, 1, 1, 0.5f), Corners, 3.0f);
@@ -336,11 +351,11 @@ int CMenus::DoEditBox(void *pID, const CUIRect *pRect, char *pStr, unsigned StrS
 	return ReturnValue;
 }
 
-float CMenus::DoScrollbarV(const void *pID, const CUIRect *pRect, float Current)
+float CMenus::DoScrollbarV(const void *pID, const CUIRect *pRect, float Current, float PageScrollDistance)
 {
 	CUIRect Handle;
 	static float OffsetY;
-	pRect->HSplitTop(33, &Handle, 0);
+	pRect->HSplitTop(50, &Handle, 0);
 
 	Handle.y += (pRect->h-Handle.h)*Current;
 
@@ -372,6 +387,20 @@ float CMenus::DoScrollbarV(const void *pID, const CUIRect *pRect, float Current)
 	if(Inside)
 		UI()->SetHotItem(pID);
 
+	int Outside = UI()->MouseInside(pRect);
+	if(Outside && !Inside)
+	{
+		if(UI()->MouseButtonClicked(0))
+		{
+			if (UI()->MouseY() < Handle.y)
+				ReturnValue -= PageScrollDistance;
+			else
+				ReturnValue += PageScrollDistance;
+			if(ReturnValue < 0.0f) ReturnValue = 0.0f;
+			if(ReturnValue > 1.0f) ReturnValue = 1.0f;
+		}
+	}
+
 	// render
 	CUIRect Rail;
 	pRect->VMargin(5.0f, &Rail);
@@ -544,6 +573,7 @@ int CMenus::RenderMenubar(CUIRect r)
 		{
 			ServerBrowser()->Refresh(IServerBrowser::TYPE_INTERNET);
 			NewPage = PAGE_INTERNET;
+			m_DoubleClickIndex = -1;
 		}
 
 		//Box.VSplitLeft(4.0f, 0, &Box);
@@ -553,6 +583,7 @@ int CMenus::RenderMenubar(CUIRect r)
 		{
 			ServerBrowser()->Refresh(IServerBrowser::TYPE_LAN);
 			NewPage = PAGE_LAN;
+			m_DoubleClickIndex = -1;
 		}
 
 		//box.VSplitLeft(4.0f, 0, &box);
@@ -562,6 +593,7 @@ int CMenus::RenderMenubar(CUIRect r)
 		{
 			ServerBrowser()->Refresh(IServerBrowser::TYPE_FAVORITES);
 			NewPage = PAGE_FAVORITES;
+			m_DoubleClickIndex = -1;
 		}
 
 		Box.VSplitLeft(4.0f*5, 0, &Box);
@@ -571,6 +603,17 @@ int CMenus::RenderMenubar(CUIRect r)
 		{
 			DemolistPopulate();
 			NewPage = PAGE_DEMOS;
+			m_DoubleClickIndex = -1;
+		}
+
+		Box.VSplitLeft(4.0f*5, 0, &Box);
+		Box.VSplitLeft(100.0f, &Button, &Box);
+		static int s_ServerButton=0;
+		if(DoButton_MenuTab(&s_ServerButton, Localize("Server"), m_ActivePage==PAGE_SERVER, &Button, CUI::CORNER_T))
+		{
+			ServerCreatorInit();
+			NewPage = PAGE_SERVER;
+			m_DoubleClickIndex = -1;
 		}
 	}
 	else
@@ -778,6 +821,7 @@ int CMenus::Render()
 			ServerBrowser()->Refresh(IServerBrowser::TYPE_FAVORITES);
 		m_pClient->m_pSounds->Enqueue(CSounds::CHN_MUSIC, SOUND_MENU);
 		s_First = false;
+		m_DoubleClickIndex = -1;
 	}
 
 	if(Client()->State() == IClient::STATE_ONLINE)
@@ -809,7 +853,7 @@ int CMenus::Render()
 	if(m_Popup == POPUP_NONE)
 	{
 		// do tab bar
-		Screen.HSplitTop(24.0f, &TabBar, &MainView);
+		Screen.HSplitTop(100.0f, &TabBar, &MainView);
 		TabBar.VMargin(20.0f, &TabBar);
 		RenderMenubar(TabBar);
 
@@ -818,6 +862,7 @@ int CMenus::Render()
 		{
 			ServerBrowser()->Refresh(IServerBrowser::TYPE_INTERNET);
 			g_Config.m_UiPage = PAGE_INTERNET;
+			m_DoubleClickIndex = -1;
 		}
 
 		// render current page
@@ -842,6 +887,8 @@ int CMenus::Render()
 			RenderServerbrowser(MainView);
 		else if(g_Config.m_UiPage == PAGE_DEMOS)
 			RenderDemoList(MainView);
+		else if(g_Config.m_UiPage == PAGE_SERVER)
+			ServerCreatorProcess(MainView);
 		else if(g_Config.m_UiPage == PAGE_FAVORITES)
 			RenderServerbrowser(MainView);
 		else if(g_Config.m_UiPage == PAGE_SETTINGS)
@@ -937,7 +984,7 @@ int CMenus::Render()
 		CUIRect Box, Part;
 		Box = Screen;
 		Box.VMargin(150.0f/UI()->Scale(), &Box);
-		Box.HMargin(150.0f/UI()->Scale(), &Box);
+		Box.HMargin(100.0f/UI()->Scale(), &Box);
 
 		// render the box
 		RenderTools()->DrawUIRect(&Box, vec4(0,0,0,0.5f), CUI::CORNER_ALL, 15.0f);
@@ -958,7 +1005,7 @@ int CMenus::Render()
 		{
 			CUIRect Yes, No;
 			Box.HSplitBottom(20.f, &Box, &Part);
-			Box.HSplitBottom(24.f, &Box, &Part);
+			Box.HSplitBottom(60.f, &Box, &Part);
 
 			// additional info
 			Box.HSplitTop(10.0f, 0, &Box);
@@ -989,7 +1036,7 @@ int CMenus::Render()
 			CUIRect Label, TextBox, TryAgain, Abort;
 
 			Box.HSplitBottom(20.f, &Box, &Part);
-			Box.HSplitBottom(24.f, &Box, &Part);
+			Box.HSplitBottom(60.f, &Box, &Part);
 			Part.VMargin(80.0f, &Part);
 
 			Part.VSplitMid(&Abort, &TryAgain);
@@ -1008,7 +1055,7 @@ int CMenus::Render()
 			}
 
 			Box.HSplitBottom(60.f, &Box, &Part);
-			Box.HSplitBottom(24.f, &Box, &Part);
+			Box.HSplitBottom(60.f, &Box, &Part);
 
 			Part.VSplitLeft(60.0f, 0, &Label);
 			Label.VSplitLeft(100.0f, 0, &TextBox);
@@ -1024,7 +1071,7 @@ int CMenus::Render()
 			Box.VMargin(150.0f, &Box);
 			Box.HMargin(150.0f, &Box);
 			Box.HSplitBottom(20.f, &Box, &Part);
-			Box.HSplitBottom(24.f, &Box, &Part);
+			Box.HSplitBottom(60.f, &Box, &Part);
 			Part.VMargin(120.0f, &Part);
 
 			static int s_Button = 0;
@@ -1089,10 +1136,10 @@ int CMenus::Render()
 		{
 			Box = Screen;
 			Box.VMargin(150.0f, &Box);
-			Box.HMargin(150.0f, &Box);
+			Box.HMargin(20.0f, &Box);
 			Box.HSplitTop(20.f, &Part, &Box);
 			Box.HSplitBottom(20.f, &Box, &Part);
-			Box.HSplitBottom(24.f, &Box, &Part);
+			Box.HSplitBottom(60.f, &Box, &Part);
 			Box.HSplitBottom(20.f, &Box, 0);
 			Box.VMargin(20.0f, &Box);
 			RenderLanguageSelection(Box);
@@ -1109,7 +1156,7 @@ int CMenus::Render()
 			Box.HMargin(150.0f, &Box);
 			Box.HSplitTop(20.f, &Part, &Box);
 			Box.HSplitBottom(20.f, &Box, &Part);
-			Box.HSplitBottom(24.f, &Box, &Part);
+			Box.HSplitBottom(60.f, &Box, &Part);
 			Box.HSplitBottom(20.f, &Box, 0);
 			Box.VMargin(20.0f, &Box);
 
@@ -1165,7 +1212,7 @@ int CMenus::Render()
 		{
 			CUIRect Yes, No;
 			Box.HSplitBottom(20.f, &Box, &Part);
-			Box.HSplitBottom(24.f, &Box, &Part);
+			Box.HSplitBottom(60.f, &Box, &Part);
 			Part.VMargin(80.0f, &Part);
 
 			Part.VSplitMid(&No, &Yes);
@@ -1201,7 +1248,7 @@ int CMenus::Render()
 			CUIRect Label, TextBox, Ok, Abort;
 
 			Box.HSplitBottom(20.f, &Box, &Part);
-			Box.HSplitBottom(24.f, &Box, &Part);
+			Box.HSplitBottom(60.f, &Box, &Part);
 			Part.VMargin(80.0f, &Part);
 
 			Part.VSplitMid(&Abort, &Ok);
@@ -1239,7 +1286,7 @@ int CMenus::Render()
 			}
 
 			Box.HSplitBottom(60.f, &Box, &Part);
-			Box.HSplitBottom(24.f, &Box, &Part);
+			Box.HSplitBottom(60.f, &Box, &Part);
 
 			Part.VSplitLeft(60.0f, 0, &Label);
 			Label.VSplitLeft(120.0f, 0, &TextBox);
@@ -1253,7 +1300,7 @@ int CMenus::Render()
 		{
 			CUIRect Yes, No;
 			Box.HSplitBottom(20.f, &Box, &Part);
-			Box.HSplitBottom(24.f, &Box, &Part);
+			Box.HSplitBottom(60.f, &Box, &Part);
 			Part.VMargin(80.0f, &Part);
 
 			Part.VSplitMid(&No, &Yes);
@@ -1284,7 +1331,7 @@ int CMenus::Render()
 			CUIRect Label, TextBox;
 
 			Box.HSplitBottom(20.f, &Box, &Part);
-			Box.HSplitBottom(24.f, &Box, &Part);
+			Box.HSplitBottom(60.f, &Box, &Part);
 			Part.VMargin(80.0f, &Part);
 
 			static int s_EnterButton = 0;
@@ -1292,7 +1339,7 @@ int CMenus::Render()
 				m_Popup = POPUP_NONE;
 
 			Box.HSplitBottom(40.f, &Box, &Part);
-			Box.HSplitBottom(24.f, &Box, &Part);
+			Box.HSplitBottom(60.f, &Box, &Part);
 
 			Part.VSplitLeft(60.0f, 0, &Label);
 			Label.VSplitLeft(100.0f, 0, &TextBox);
@@ -1305,7 +1352,7 @@ int CMenus::Render()
 		else
 		{
 			Box.HSplitBottom(20.f, &Box, &Part);
-			Box.HSplitBottom(24.f, &Box, &Part);
+			Box.HSplitBottom(60.f, &Box, &Part);
 			Part.VMargin(120.0f, &Part);
 
 			static int s_Button = 0;
@@ -1324,6 +1371,7 @@ int CMenus::Render()
 void CMenus::SetActive(bool Active)
 {
 	m_MenuActive = Active;
+	UI()->AndroidShowScreenKeys(!m_MenuActive && !m_pClient->m_pControls->m_UsingGamepad);
 	if(!m_MenuActive)
 	{
 		if(m_NeedSendinfo)
@@ -1354,9 +1402,15 @@ bool CMenus::OnMouseMove(float x, float y)
 	if(!m_MenuActive)
 		return false;
 
+#if defined(__ANDROID__) // No relative mouse on Android
+	m_MousePos.x = x;
+	m_MousePos.y = y;
+#else
 	UI()->ConvertMouseMove(&x, &y);
 	m_MousePos.x += x;
 	m_MousePos.y += y;
+#endif
+
 	if(m_MousePos.x < 0) m_MousePos.x = 0;
 	if(m_MousePos.y < 0) m_MousePos.y = 0;
 	if(m_MousePos.x > Graphics()->ScreenWidth()) m_MousePos.x = Graphics()->ScreenWidth();
@@ -1518,7 +1572,10 @@ void CMenus::OnRender()
 		if(Input()->KeyPressed(KEY_MOUSE_3)) Buttons |= 4;
 	}
 
-	UI()->Update(mx,my,mx*3.0f,my*3.0f,Buttons);
+	static int ButtonsOneFrameDelay = 0; // For Android touch input
+
+	UI()->Update(mx,my,mx*3.0f,my*3.0f,ButtonsOneFrameDelay);
+	ButtonsOneFrameDelay = Buttons;
 
 	// render
 	if(Client()->State() != IClient::STATE_DEMOPLAYBACK)
diff --git a/src/game/client/components/menus.h b/src/game/client/components/menus.h
index 0125278..dc88c1b 100644
--- a/src/game/client/components/menus.h
+++ b/src/game/client/components/menus.h
@@ -67,7 +67,7 @@ class CMenus : public CComponent
 	int DoEditBox(void *pID, const CUIRect *pRect, char *pStr, unsigned StrSize, float FontSize, float *Offset, bool Hidden=false, int Corners=CUI::CORNER_ALL);
 	//static int ui_do_edit_box(void *id, const CUIRect *rect, char *str, unsigned str_size, float font_size, bool hidden=false);
 
-	float DoScrollbarV(const void *pID, const CUIRect *pRect, float Current);
+	float DoScrollbarV(const void *pID, const CUIRect *pRect, float Current, float PageScrollDistance = 0.001f);
 	float DoScrollbarH(const void *pID, const CUIRect *pRect, float Current);
 	void DoButton_KeySelect(const void *pID, const char *pText, int Checked, const CUIRect *pRect);
 	int DoKeyReader(void *pID, const CUIRect *pRect, int Key);
@@ -121,6 +121,7 @@ class CMenus : public CComponent
 		PAGE_LAN,
 		PAGE_FAVORITES,
 		PAGE_DEMOS,
+		PAGE_SERVER,
 		PAGE_SETTINGS,
 		PAGE_SYSTEM,
 	};
@@ -153,6 +154,7 @@ class CMenus : public CComponent
 	// some settings
 	static float ms_ButtonHeight;
 	static float ms_ListheaderHeight;
+	static float ms_ListitemAdditionalHeight;
 	static float ms_FontmodHeight;
 
 	// for settings
@@ -243,6 +245,10 @@ class CMenus : public CComponent
 	void RenderDemoPlayer(CUIRect MainView);
 	void RenderDemoList(CUIRect MainView);
 
+	// found in menus_server.cpp
+	void ServerCreatorInit();
+	void ServerCreatorProcess(CUIRect MainView);
+
 	// found in menus_ingame.cpp
 	void RenderGame(CUIRect MainView);
 	void RenderPlayers(CUIRect MainView);
@@ -253,6 +259,7 @@ class CMenus : public CComponent
 
 	// found in menus_browser.cpp
 	int m_SelectedIndex;
+	int m_DoubleClickIndex;
 	int m_ScrollOffset;
 	void RenderServerbrowserServerList(CUIRect View);
 	void RenderServerbrowserServerDetail(CUIRect View);
diff --git a/src/game/client/components/menus_browser.cpp b/src/game/client/components/menus_browser.cpp
index 42805e0..b88a602 100644
--- a/src/game/client/components/menus_browser.cpp
+++ b/src/game/client/components/menus_browser.cpp
@@ -71,6 +71,7 @@ void CMenus::RenderServerbrowserServerList(CUIRect View)
 		{COL_PLAYERS,	IServerBrowser::SORT_NUMPLAYERS,	"Players",	1, 60.0f, 0, {0}, {0}},
 		{-1,			-1,						" ",		1, 10.0f, 0, {0}, {0}},
 		{COL_PING,		IServerBrowser::SORT_PING,		"Ping",		1, 40.0f, FIXED, {0}, {0}},
+		{-1,			-1,						" ",		1, 50.0f, 0, {0}, {0}}, // Scrollbar
 	};
 	// This is just for scripts/update_localization.py to work correctly (all other strings are already Localize()'d somewhere else). Don't remove!
 	// Localize("Type");
@@ -126,7 +127,7 @@ void CMenus::RenderServerbrowserServerList(CUIRect View)
 	RenderTools()->DrawUIRect(&View, vec4(0,0,0,0.15f), 0, 0);
 
 	CUIRect Scroll;
-	View.VSplitRight(15, &View, &Scroll);
+	View.VSplitRight(50, &View, &Scroll);
 
 	int NumServers = ServerBrowser()->NumSortedServers();
 
@@ -149,7 +150,7 @@ void CMenus::RenderServerbrowserServerList(CUIRect View)
 	static float s_ScrollValue = 0;
 
 	Scroll.HMargin(5.0f, &Scroll);
-	s_ScrollValue = DoScrollbarV(&s_ScrollBar, &Scroll, s_ScrollValue);
+	s_ScrollValue = DoScrollbarV(&s_ScrollBar, &Scroll, s_ScrollValue, (float)(Num - 1) / NumServers);
 
 	int ScrollNum = NumServers-Num+1;
 	if(ScrollNum > 0)
@@ -214,6 +215,7 @@ void CMenus::RenderServerbrowserServerList(CUIRect View)
 	View.y -= s_ScrollValue*ScrollNum*s_aCols[0].m_Rect.h;
 
 	int NewSelected = -1;
+	int DoubleClicked = 0;
 	int NumPlayers = 0;
 
 	m_SelectedIndex = -1;
@@ -231,7 +233,7 @@ void CMenus::RenderServerbrowserServerList(CUIRect View)
 
 		int Selected = str_comp(pItem->m_aAddress, g_Config.m_UiServerAddress) == 0; //selected_index==ItemIndex;
 
-		View.HSplitTop(17.0f, &Row, &View);
+		View.HSplitTop(ms_ListheaderHeight, &Row, &View);
 		SelectHitBox = Row;
 
 		if(Selected)
@@ -282,6 +284,9 @@ void CMenus::RenderServerbrowserServerList(CUIRect View)
 			if(UI()->DoButtonLogic(pItem, "", Selected, &SelectHitBox))
 			{
 				NewSelected = ItemIndex;
+				if( NewSelected == m_DoubleClickIndex )
+					DoubleClicked = 1;
+				m_DoubleClickIndex = NewSelected;
 			}
 		}
 		else
@@ -307,11 +312,15 @@ void CMenus::RenderServerbrowserServerList(CUIRect View)
 
 			if(ID == COL_FLAG_LOCK)
 			{
+				Button.h = Button.w;
+				Button.y += ms_ListitemAdditionalHeight / 2;
 				if(pItem->m_Flags & SERVER_FLAG_PASSWORD)
 					DoButton_Icon(IMAGE_BROWSEICONS, SPRITE_BROWSE_LOCK, &Button);
 			}
 			else if(ID == COL_FLAG_PURE)
 			{
+				Button.h = Button.w;
+				Button.y += ms_ListitemAdditionalHeight / 2;
 				if(	str_comp(pItem->m_aGameType, "DM") == 0 ||
 					str_comp(pItem->m_aGameType, "TDM") == 0 ||
 					str_comp(pItem->m_aGameType, "CTF") == 0)
@@ -326,13 +335,15 @@ void CMenus::RenderServerbrowserServerList(CUIRect View)
 			}
 			else if(ID == COL_FLAG_FAV)
 			{
+				Button.h = Button.w;
+				Button.y += ms_ListitemAdditionalHeight / 2;
 				if(pItem->m_Favorite)
 					DoButton_Icon(IMAGE_BROWSEICONS, SPRITE_BROWSE_HEART, &Button);
 			}
 			else if(ID == COL_NAME)
 			{
 				CTextCursor Cursor;
-				TextRender()->SetCursor(&Cursor, Button.x, Button.y, 12.0f * UI()->Scale(), TEXTFLAG_RENDER|TEXTFLAG_STOP_AT_END);
+				TextRender()->SetCursor(&Cursor, Button.x, Button.y + ms_ListitemAdditionalHeight / 2, 12.0f * UI()->Scale(), TEXTFLAG_RENDER|TEXTFLAG_STOP_AT_END);
 				Cursor.m_LineWidth = Button.w;
 
 				if(g_Config.m_BrFilterString[0] && (pItem->m_QuickSearchHit&IServerBrowser::QUICK_SERVERNAME))
@@ -356,7 +367,7 @@ void CMenus::RenderServerbrowserServerList(CUIRect View)
 			else if(ID == COL_MAP)
 			{
 				CTextCursor Cursor;
-				TextRender()->SetCursor(&Cursor, Button.x, Button.y, 12.0f * UI()->Scale(), TEXTFLAG_RENDER|TEXTFLAG_STOP_AT_END);
+				TextRender()->SetCursor(&Cursor, Button.x, Button.y + ms_ListitemAdditionalHeight / 2, 12.0f * UI()->Scale(), TEXTFLAG_RENDER|TEXTFLAG_STOP_AT_END);
 				Cursor.m_LineWidth = Button.w;
 
 				if(g_Config.m_BrFilterString[0] && (pItem->m_QuickSearchHit&IServerBrowser::QUICK_MAPNAME))
@@ -379,6 +390,8 @@ void CMenus::RenderServerbrowserServerList(CUIRect View)
 			}
 			else if(ID == COL_PLAYERS)
 			{
+				Button.h -= ms_ListitemAdditionalHeight;
+				Button.y += ms_ListitemAdditionalHeight / 2;
 				CUIRect Icon;
 				Button.VMargin(4.0f, &Button);
 				if(pItem->m_FriendState != IFriends::FRIEND_NO)
@@ -399,18 +412,22 @@ void CMenus::RenderServerbrowserServerList(CUIRect View)
 			}
 			else if(ID == COL_PING)
 			{
+				Button.h -= ms_ListitemAdditionalHeight;
+				Button.y += ms_ListitemAdditionalHeight / 2;
 				str_format(aTemp, sizeof(aTemp), "%i", pItem->m_Latency);
 				UI()->DoLabelScaled(&Button, aTemp, 12.0f, 1);
 			}
 			else if(ID == COL_VERSION)
 			{
+				Button.h -= ms_ListitemAdditionalHeight;
+				Button.y += ms_ListitemAdditionalHeight / 2;
 				const char *pVersion = pItem->m_aVersion;
 				UI()->DoLabelScaled(&Button, pVersion, 12.0f, 1);
 			}
 			else if(ID == COL_GAMETYPE)
 			{
 				CTextCursor Cursor;
-				TextRender()->SetCursor(&Cursor, Button.x, Button.y, 12.0f*UI()->Scale(), TEXTFLAG_RENDER|TEXTFLAG_STOP_AT_END);
+				TextRender()->SetCursor(&Cursor, Button.x, Button.y + ms_ListitemAdditionalHeight / 2, 12.0f*UI()->Scale(), TEXTFLAG_RENDER|TEXTFLAG_STOP_AT_END);
 				Cursor.m_LineWidth = Button.w;
 				TextRender()->TextEx(&Cursor, pItem->m_aGameType, -1);
 			}
@@ -425,7 +442,7 @@ void CMenus::RenderServerbrowserServerList(CUIRect View)
 		// select the new server
 		const CServerInfo *pItem = ServerBrowser()->SortedGet(NewSelected);
 		str_copy(g_Config.m_UiServerAddress, pItem->m_aAddress, sizeof(g_Config.m_UiServerAddress));
-		if(Input()->MouseDoubleClick())
+		if(DoubleClicked) // DoubleClickedInput()->MouseDoubleClick()
 			Client()->Connect(g_Config.m_UiServerAddress);
 	}
 
@@ -808,7 +825,7 @@ void CMenus::RenderServerbrowserFriends(CUIRect View)
 	static float s_ScrollValue = 0;
 	if(m_FriendlistSelectedIndex >= m_lFriends.size())
 		m_FriendlistSelectedIndex = m_lFriends.size()-1;
-	UiDoListboxStart(&m_lFriends, &List, 30.0f, "", "", m_lFriends.size(), 1, m_FriendlistSelectedIndex, s_ScrollValue);
+	UiDoListboxStart(&m_lFriends, &List, 50.0f, "", "", m_lFriends.size(), 1, m_FriendlistSelectedIndex, s_ScrollValue);
 
 	m_lFriends.sort_range();
 	for(int i = 0; i < m_lFriends.size(); ++i)
@@ -1020,6 +1037,7 @@ void CMenus::RenderServerbrowser(CUIRect MainView)
 				ServerBrowser()->Refresh(IServerBrowser::TYPE_LAN);
 			else if(g_Config.m_UiPage == PAGE_FAVORITES)
 				ServerBrowser()->Refresh(IServerBrowser::TYPE_FAVORITES);
+			m_DoubleClickIndex = -1;
 		}
 
 		ButtonArea.HSplitTop(5.0f, 0, &ButtonArea);
diff --git a/src/game/client/components/menus_demo.cpp b/src/game/client/components/menus_demo.cpp
index 40a9e5b..d4a3247 100644
--- a/src/game/client/components/menus_demo.cpp
+++ b/src/game/client/components/menus_demo.cpp
@@ -284,7 +284,7 @@ void CMenus::UiDoListboxStart(const void *pID, const CUIRect *pRect, float RowHe
 	RenderTools()->DrawUIRect(&View, vec4(0,0,0,0.15f), 0, 0);
 
 	// prepare the scroll
-	View.VSplitRight(15, &View, &Scroll);
+	View.VSplitRight(50, &View, &Scroll);
 
 	// setup the variables
 	gs_ListBoxOriginalView = View;
@@ -616,7 +616,7 @@ void CMenus::RenderDemoList(CUIRect MainView)
 
 	static int s_DemoListId = 0;
 	static float s_ScrollValue = 0;
-	UiDoListboxStart(&s_DemoListId, &ListBox, 17.0f, Localize("Demos"), aFooterLabel, m_lDemos.size(), 1, m_DemolistSelectedIndex, s_ScrollValue);
+	UiDoListboxStart(&s_DemoListId, &ListBox, 50.0f, Localize("Demos"), aFooterLabel, m_lDemos.size(), 1, m_DemolistSelectedIndex, s_ScrollValue);
 	for(sorted_array<CDemoItem>::range r = m_lDemos.all(); !r.empty(); r.pop_front())
 	{
 		CListboxItem Item = UiDoListboxNextItem((void*)(&r.front()));
diff --git a/src/game/client/components/menus_ingame.cpp b/src/game/client/components/menus_ingame.cpp
index 084520d..483527d 100644
--- a/src/game/client/components/menus_ingame.cpp
+++ b/src/game/client/components/menus_ingame.cpp
@@ -26,12 +26,12 @@
 void CMenus::RenderGame(CUIRect MainView)
 {
 	CUIRect Button, ButtonBar;
-	MainView.HSplitTop(45.0f, &ButtonBar, &MainView);
+	MainView.HSplitTop(100.0f, &ButtonBar, &MainView);
 	RenderTools()->DrawUIRect(&ButtonBar, ms_ColorTabbarActive, CUI::CORNER_ALL, 10.0f);
 
 	// button bar
 	ButtonBar.HSplitTop(10.0f, 0, &ButtonBar);
-	ButtonBar.HSplitTop(25.0f, &ButtonBar, 0);
+	ButtonBar.HSplitTop(80.0f, &ButtonBar, 0);
 	ButtonBar.VMargin(10.0f, &ButtonBar);
 
 	ButtonBar.VSplitRight(120.0f, &ButtonBar, &Button);
@@ -372,7 +372,7 @@ void CMenus::RenderServerControlServer(CUIRect MainView)
 	static int s_VoteList = 0;
 	static float s_ScrollValue = 0;
 	CUIRect List = MainView;
-	UiDoListboxStart(&s_VoteList, &List, 24.0f, "", "", m_pClient->m_pVoting->m_NumVoteOptions, 1, m_CallvoteSelectedOption, s_ScrollValue);
+	UiDoListboxStart(&s_VoteList, &List, 50.0f, "", "", m_pClient->m_pVoting->m_NumVoteOptions, 1, m_CallvoteSelectedOption, s_ScrollValue);
 
 	for(CVoteOptionClient *pOption = m_pClient->m_pVoting->m_pFirst; pOption; pOption = pOption->m_pNext)
 	{
@@ -406,7 +406,7 @@ void CMenus::RenderServerControlKick(CUIRect MainView, bool FilterSpectators)
 	static int s_VoteList = 0;
 	static float s_ScrollValue = 0;
 	CUIRect List = MainView;
-	UiDoListboxStart(&s_VoteList, &List, 24.0f, "", "", NumOptions, 1, Selected, s_ScrollValue);
+	UiDoListboxStart(&s_VoteList, &List, 50.0f, "", "", NumOptions, 1, Selected, s_ScrollValue);
 
 	for(int i = 0; i < NumOptions; i++)
 	{
@@ -433,12 +433,12 @@ void CMenus::RenderServerControl(CUIRect MainView)
 
 	// render background
 	CUIRect Bottom, Extended, TabBar, Button;
-	MainView.HSplitTop(20.0f, &Bottom, &MainView);
+	MainView.HSplitTop(50.0f, &Bottom, &MainView);
 	RenderTools()->DrawUIRect(&Bottom, ms_ColorTabbarActive, CUI::CORNER_T, 10.0f);
-	MainView.HSplitTop(20.0f, &TabBar, &MainView);
+	MainView.HSplitTop(50.0f, &TabBar, &MainView);
 	RenderTools()->DrawUIRect(&MainView, ms_ColorTabbarActive, CUI::CORNER_B, 10.0f);
 	MainView.Margin(10.0f, &MainView);
-	MainView.HSplitBottom(90.0f, &MainView, &Extended);
+	MainView.HSplitBottom(10.0f, &MainView, &Extended);
 
 	// tab bar
 	{
diff --git a/src/game/client/components/menus_server.cpp b/src/game/client/components/menus_server.cpp
new file mode 100644
index 0000000..6d19035
diff --git a/src/game/client/components/menus_settings.cpp b/src/game/client/components/menus_settings.cpp
index b2434d9..6944b56 100644
--- a/src/game/client/components/menus_settings.cpp
+++ b/src/game/client/components/menus_settings.cpp
@@ -53,7 +53,7 @@ void CMenus::RenderSettingsGeneral(CUIRect MainView)
 {
 	char aBuf[128];
 	CUIRect Label, Button, Left, Right, Game, Client;
-	MainView.HSplitTop(150.0f, &Game, &Client);
+	MainView.HSplitTop(300.0f, &Game, &Client);
 
 	// game
 	{
@@ -66,7 +66,7 @@ void CMenus::RenderSettingsGeneral(CUIRect MainView)
 		Right.VMargin(5.0f, &Right);
 
 		// dynamic camera
-		Left.HSplitTop(20.0f, &Button, &Left);
+		Right.HSplitTop(20.0f, &Button, &Right);
 		static int s_DynamicCameraButton = 0;
 		if(DoButton_CheckBox(&s_DynamicCameraButton, Localize("Dynamic Camera"), g_Config.m_ClMouseDeadzone != 0, &Button))
 		{
@@ -85,24 +85,68 @@ void CMenus::RenderSettingsGeneral(CUIRect MainView)
 		}
 
 		// weapon pickup
-		Left.HSplitTop(5.0f, 0, &Left);
+		//Left.HSplitTop(5.0f, 0, &Left);
 		Left.HSplitTop(20.0f, &Button, &Left);
 		if(DoButton_CheckBox(&g_Config.m_ClAutoswitchWeapons, Localize("Switch weapon on pickup"), g_Config.m_ClAutoswitchWeapons, &Button))
 			g_Config.m_ClAutoswitchWeapons ^= 1;
 
-		// show hud
+		// weapon out of ammo autoswitch
 		Left.HSplitTop(5.0f, 0, &Left);
 		Left.HSplitTop(20.0f, &Button, &Left);
+		if(DoButton_CheckBox(&g_Config.m_ClAutoswitchWeaponsOutOfAmmo, Localize("Switch weapon when out of ammo"), g_Config.m_ClAutoswitchWeaponsOutOfAmmo, &Button))
+			g_Config.m_ClAutoswitchWeaponsOutOfAmmo ^= 1;
+
+		// show hud
+		Right.HSplitTop(5.0f, 0, &Right);
+		Right.HSplitTop(20.0f, &Button, &Right);
 		if(DoButton_CheckBox(&g_Config.m_ClShowhud, Localize("Show ingame HUD"), g_Config.m_ClShowhud, &Button))
 			g_Config.m_ClShowhud ^= 1;
 
 		// chat messages
-		Left.HSplitTop(5.0f, 0, &Left);
-		Left.HSplitTop(20.0f, &Button, &Left);
+		Right.HSplitTop(5.0f, 0, &Right);
+		Right.HSplitTop(20.0f, &Button, &Right);
 		if(DoButton_CheckBox(&g_Config.m_ClShowChatFriends, Localize("Show only chat messages from friends"), g_Config.m_ClShowChatFriends, &Button))
 			g_Config.m_ClShowChatFriends ^= 1;
 
+
+		Left.HSplitTop(5.0f, 0, &Left);
+		Left.HSplitTop(20.0f, &Label, &Left);
+		UI()->DoLabelScaled(&Label, Localize("Touchscreen controls preset"), 13.0f, -1);
+
+		int TouchscreenTwoJoysticks = g_Config.m_ClTouchscreenMode == TOUCHSCREEN_TWO_JOYSTICKS;
+		int TouchscreenThreeJoysticks = g_Config.m_ClTouchscreenMode == TOUCHSCREEN_THREE_JOYSTICKS;
+		int TouchscreenAccelerometer = g_Config.m_ClTouchscreenMode == TOUCHSCREEN_ACCELEROMETER;
+		int TouchscreenDDRace = g_Config.m_ClTouchscreenMode == TOUCHSCREEN_DDRACE;
+		int TouchscreenVolumeKeys = g_Config.m_ClTouchscreenMode == TOUCHSCREEN_VOLUME_KEYS;
+
+		Left.HSplitTop(5.0f, 0, &Left);
+		Left.HSplitTop(20.0f, &Button, &Left);
+		if(DoButton_CheckBox(&TouchscreenTwoJoysticks, Localize("Two joysticks, separate Fire and Hook buttons"), TouchscreenTwoJoysticks, &Button))
+			g_Config.m_ClTouchscreenMode = TOUCHSCREEN_TWO_JOYSTICKS;
+
+		Left.HSplitTop(5.0f, 0, &Left);
+		Left.HSplitTop(20.0f, &Button, &Left);
+		if(DoButton_CheckBox(&TouchscreenThreeJoysticks, Localize("Three joysticks, Fire and Hook activated by joysticks"), TouchscreenThreeJoysticks, &Button))
+			g_Config.m_ClTouchscreenMode = TOUCHSCREEN_THREE_JOYSTICKS;
+
+		Left.HSplitTop(5.0f, 0, &Left);
+		Left.HSplitTop(20.0f, &Button, &Left);
+		if(DoButton_CheckBox(&TouchscreenAccelerometer, Localize("One joystick + accelerometer, separate Fire button"), TouchscreenAccelerometer, &Button))
+			g_Config.m_ClTouchscreenMode = TOUCHSCREEN_ACCELEROMETER;
+
+		Left.HSplitTop(5.0f, 0, &Left);
+		Left.HSplitTop(20.0f, &Button, &Left);
+		if(DoButton_CheckBox(&TouchscreenDDRace, Localize("Two joysticks DDRace, Hook activated by joystick"), TouchscreenDDRace, &Button))
+			g_Config.m_ClTouchscreenMode = TOUCHSCREEN_DDRACE;
+
+		Left.HSplitTop(5.0f, 0, &Left);
+		Left.HSplitTop(20.0f, &Button, &Left);
+		if(DoButton_CheckBox(&TouchscreenVolumeKeys, Localize("Two joysticks, Hook activated by Volume keys"), TouchscreenVolumeKeys, &Button))
+			g_Config.m_ClTouchscreenMode = TOUCHSCREEN_VOLUME_KEYS;
+
+
 		// name plates
+		Right.HSplitTop(5.0f, 0, &Right);
 		Right.HSplitTop(20.0f, &Button, &Right);
 		if(DoButton_CheckBox(&g_Config.m_ClNameplates, Localize("Show name plates"), g_Config.m_ClNameplates, &Button))
 			g_Config.m_ClNameplates ^= 1;
@@ -127,6 +171,17 @@ void CMenus::RenderSettingsGeneral(CUIRect MainView)
 			if(DoButton_CheckBox(&g_Config.m_ClNameplatesTeamcolors, Localize("Use team colors for name plates"), g_Config.m_ClNameplatesTeamcolors, &Button))
 				g_Config.m_ClNameplatesTeamcolors ^= 1;
 		}
+
+		if(TouchscreenAccelerometer)
+		{
+			Right.HSplitTop(10.0f, 0, &Right);
+			Right.HSplitTop(20.0f, &Label, &Right);
+			Right.HSplitTop(20.0f, &Button, &Right);
+			Label.VSplitLeft(20.0f, 0, &Label);
+			UI()->DoLabelScaled(&Label, Localize("Accelerometer sensitivity"), 13.0f, -1);
+			Button.HMargin(2.0f, &Button);
+			g_Config.m_ClAccelerometerSensitivity = static_cast<int>(DoScrollbarH(&g_Config.m_ClAccelerometerSensitivity, &Button, g_Config.m_ClAccelerometerSensitivity/10000.0f)*10000.0f);
+		}
 	}
 
 	// client
@@ -513,13 +568,13 @@ void CMenus::RenderSettingsControls(CUIRect MainView)
 	// movement settings
 	{
 		MovementSettings.VMargin(5.0f, &MovementSettings);
-		MovementSettings.HSplitTop(MainView.h/3+60.0f, &MovementSettings, &WeaponSettings);
+		MovementSettings.HSplitTop(MainView.h/3 + 40.0f, &MovementSettings, &WeaponSettings);
 		RenderTools()->DrawUIRect(&MovementSettings, vec4(1,1,1,0.25f), CUI::CORNER_ALL, 10.0f);
 		MovementSettings.Margin(10.0f, &MovementSettings);
 
-		TextRender()->Text(0, MovementSettings.x, MovementSettings.y, 14.0f*UI()->Scale(), Localize("Movement"), -1);
+		//TextRender()->Text(0, MovementSettings.x, MovementSettings.y, 14.0f*UI()->Scale(), Localize("Movement"), -1);
 
-		MovementSettings.HSplitTop(14.0f+5.0f+10.0f, 0, &MovementSettings);
+		//MovementSettings.HSplitTop(14.0f+5.0f+10.0f, 0, &MovementSettings);
 
 		{
 			CUIRect Button, Label;
@@ -543,9 +598,9 @@ void CMenus::RenderSettingsControls(CUIRect MainView)
 		RenderTools()->DrawUIRect(&WeaponSettings, vec4(1,1,1,0.25f), CUI::CORNER_ALL, 10.0f);
 		WeaponSettings.Margin(10.0f, &WeaponSettings);
 
-		TextRender()->Text(0, WeaponSettings.x, WeaponSettings.y, 14.0f*UI()->Scale(), Localize("Weapon"), -1);
+		//TextRender()->Text(0, WeaponSettings.x, WeaponSettings.y, 14.0f*UI()->Scale(), Localize("Weapon"), -1);
 
-		WeaponSettings.HSplitTop(14.0f+5.0f+10.0f, 0, &WeaponSettings);
+		//WeaponSettings.HSplitTop(14.0f+5.0f+10.0f, 0, &WeaponSettings);
 		UiDoGetButtons(5, 12, WeaponSettings);
 	}
 
@@ -568,9 +623,9 @@ void CMenus::RenderSettingsControls(CUIRect MainView)
 		RenderTools()->DrawUIRect(&VotingSettings, vec4(1,1,1,0.25f), CUI::CORNER_ALL, 10.0f);
 		VotingSettings.Margin(10.0f, &VotingSettings);
 
-		TextRender()->Text(0, VotingSettings.x, VotingSettings.y, 14.0f*UI()->Scale(), Localize("Voting"), -1);
+		//TextRender()->Text(0, VotingSettings.x, VotingSettings.y, 14.0f*UI()->Scale(), Localize("Voting"), -1);
 
-		VotingSettings.HSplitTop(14.0f+5.0f+10.0f, 0, &VotingSettings);
+		//VotingSettings.HSplitTop(14.0f+5.0f+10.0f, 0, &VotingSettings);
 		UiDoGetButtons(12, 14, VotingSettings);
 	}
 
@@ -581,9 +636,9 @@ void CMenus::RenderSettingsControls(CUIRect MainView)
 		RenderTools()->DrawUIRect(&ChatSettings, vec4(1,1,1,0.25f), CUI::CORNER_ALL, 10.0f);
 		ChatSettings.Margin(10.0f, &ChatSettings);
 
-		TextRender()->Text(0, ChatSettings.x, ChatSettings.y, 14.0f*UI()->Scale(), Localize("Chat"), -1);
+		//TextRender()->Text(0, ChatSettings.x, ChatSettings.y, 14.0f*UI()->Scale(), Localize("Chat"), -1);
 
-		ChatSettings.HSplitTop(14.0f+5.0f+10.0f, 0, &ChatSettings);
+		//ChatSettings.HSplitTop(14.0f+5.0f+10.0f, 0, &ChatSettings);
 		UiDoGetButtons(14, 17, ChatSettings);
 	}
 
@@ -593,9 +648,9 @@ void CMenus::RenderSettingsControls(CUIRect MainView)
 		RenderTools()->DrawUIRect(&MiscSettings, vec4(1,1,1,0.25f), CUI::CORNER_ALL, 10.0f);
 		MiscSettings.Margin(10.0f, &MiscSettings);
 
-		TextRender()->Text(0, MiscSettings.x, MiscSettings.y, 14.0f*UI()->Scale(), Localize("Miscellaneous"), -1);
+		//TextRender()->Text(0, MiscSettings.x, MiscSettings.y, 14.0f*UI()->Scale(), Localize("Miscellaneous"), -1);
 
-		MiscSettings.HSplitTop(14.0f+5.0f+10.0f, 0, &MiscSettings);
+		//MiscSettings.HSplitTop(14.0f+5.0f+10.0f, 0, &MiscSettings);
 		UiDoGetButtons(17, 26, MiscSettings);
 	}
 
@@ -950,7 +1005,7 @@ void CMenus::RenderLanguageSelection(CUIRect MainView)
 
 	int OldSelected = s_SelectedLanguage;
 
-	UiDoListboxStart(&s_LanguageList , &MainView, 24.0f, Localize("Language"), "", s_Languages.size(), 1, s_SelectedLanguage, s_ScrollValue);
+	UiDoListboxStart(&s_LanguageList , &MainView, 50.0f, Localize("Language"), "", s_Languages.size(), 1, s_SelectedLanguage, s_ScrollValue);
 
 	for(sorted_array<CLanguage>::range r = s_Languages.all(); !r.empty(); r.pop_front())
 	{
diff --git a/src/game/client/components/spectator.cpp b/src/game/client/components/spectator.cpp
index c09b2ee..95bacfc 100644
--- a/src/game/client/components/spectator.cpp
+++ b/src/game/client/components/spectator.cpp
@@ -139,8 +139,12 @@ bool CSpectator::OnMouseMove(float x, float y)
 	if(!m_Active)
 		return false;
 
+#if defined(__ANDROID__) // No relative mouse on Android
+	m_SelectorMouse = vec2(x,y);
+#else
 	UI()->ConvertMouseMove(&x, &y);
 	m_SelectorMouse += vec2(x,y);
+#endif
 	return true;
 }
 
diff --git a/src/game/client/gameclient.cpp b/src/game/client/gameclient.cpp
index 77187b5..5d7086d 100644
diff --git a/src/game/client/ui.cpp b/src/game/client/ui.cpp
index c521957..99a08a5 100644
--- a/src/game/client/ui.cpp
+++ b/src/game/client/ui.cpp
@@ -7,6 +7,11 @@
 #include <engine/textrender.h>
 #include "ui.h"
 
+#if defined(__ANDROID__)
+#include <SDL.h>
+#include "SDL_screenkeyboard.h"
+#endif
+
 /********************************************************
  UI
 *********************************************************/
@@ -55,11 +60,363 @@ int CUI::MouseInside(const CUIRect *r)
 
 void CUI::ConvertMouseMove(float *x, float *y)
 {
+#if defined(__ANDROID__)
+	//*x = *x * 500 / g_Config.m_GfxScreenWidth;
+	//*y = *y * 500 / g_Config.m_GfxScreenHeight;
+#else
 	float Fac = (float)(g_Config.m_UiMousesens)/g_Config.m_InpMousesens;
 	*x = *x*Fac;
 	*y = *y*Fac;
+#endif
+}
+
+#if defined(__ANDROID__)
+static void AndroidScreenKeysTwoJoysticks(SDL_Rect Buttons[], int ScreenW, int ScreenH)
+{
+	// Second joystick to the right, and small
+	Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_DPAD2].w *= 0.6;
+	Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_DPAD2].h *= 0.6;
+	Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_DPAD2].x =
+		ScreenW - Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_DPAD2].w * 1.7;
+	Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_DPAD2].y =
+		ScreenH - Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_DPAD2].h * 1.7;
+	// Hide third joystick
+	Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_DPAD3].x = 0;
+	Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_DPAD3].y = 0;
+	Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_DPAD3].w = 0;
+	Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_DPAD3].h = 0;
+	/*
+	// Hook button above right joystick
+	Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_0].x =
+		ScreenW - Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_0].w;
+	Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_0].y =
+		Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_DPAD2].y -
+		Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_0].h;
+	// Fire button to the left of the right joystick
+	Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_2].x =
+		Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_DPAD2].x -
+		Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_2].w;
+	Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_2].y =
+		ScreenH - Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_2].h;
+	*/
+	// Hook button above right joystick
+	Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_0].w =
+		ScreenW - Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_DPAD2].x -
+		Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_DPAD2].w;
+	Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_0].x =
+		ScreenW - Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_0].w;
+	Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_0].y =
+		Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_DPAD2].y -
+		Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_0].h * 0.5;
+	// Fire button to the left of the right joystick
+	Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_2].h =
+		ScreenH - Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_DPAD2].y -
+		Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_DPAD2].h;
+	Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_2].x =
+		Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_DPAD2].x -
+		Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_2].w * 0.5;
+	Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_2].y =
+		ScreenH - Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_2].h;
+	// Weapnext button above left joystick
+	Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_1].x = 0;
+	Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_1].y =
+		Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_DPAD].y -
+		Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_1].h;
+	// Scores button above left joystick
+	Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_3].x = 0;
+	Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_3].y =
+		Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_DPAD].y -
+		Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_3].h * 2.0f;
+	// Text input button above scores
+	Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_TEXT].y =
+		Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_3].y -
+		Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_TEXT].h;
+}
+
+static void AndroidScreenKeysThreeJoysticks(SDL_Rect Buttons[], int ScreenW, int ScreenH)
+{
+	// Smaller joysticks to the right
+	Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_DPAD2].w *= 0.8;
+	Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_DPAD2].h *= 0.8;
+	Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_DPAD2].x =
+		ScreenW - Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_DPAD2].w;
+	Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_DPAD2].y =
+		ScreenH - Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_DPAD2].h;
+	Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_DPAD3].w *= 0.8;
+	Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_DPAD3].h *= 0.8;
+	Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_DPAD3].x =
+		ScreenW - Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_DPAD3].w;
+	Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_DPAD3].y =
+		Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_DPAD2].y - Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_DPAD3].h;
+	/*
+	// Weapnext button above right joystick
+	Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_1].x =
+		ScreenW - Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_1].w;
+	Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_1].y =
+		Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_DPAD3].y -
+		Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_1].h;
+	*/
+	// Weapnext button above left joystick
+	Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_1].x = 0;
+	Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_1].y =
+		Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_DPAD].y -
+		Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_1].h;
+	// Hide Hook button
+	Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_0].x =
+		Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_1].x;
+	Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_0].y =
+		Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_1].y -
+		Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_0].h;
+	Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_0].w = 0;
+	Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_0].h = 0;
+	// Hide Fire button
+	Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_2].x =
+		Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_0].x;
+	Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_2].y =
+		Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_1].y -
+		Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_2].h;
+	Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_2].w = 0;
+	Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_2].h = 0;
+	// Scores button above left joystick
+	Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_3].x = 0;
+	Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_3].y =
+		Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_DPAD].y -
+		Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_3].h * 2;
+	// Text input button above scores
+	Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_TEXT].y =
+		Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_3].y -
+		Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_TEXT].h;
+}
+
+static void AndroidScreenKeysAccelerometer(SDL_Rect Buttons[], int ScreenW, int ScreenH)
+{
+	// Joystick to the right
+	Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_DPAD].x = Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_DPAD2].x;
+	Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_DPAD].y = Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_DPAD2].y;
+	// Hide second joystick
+	Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_DPAD2].x = 0;
+	Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_DPAD2].y = 0;
+	Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_DPAD2].w = 0;
+	Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_DPAD2].h = 0;
+	// Hide third joystick
+	Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_DPAD3].x = 0;
+	Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_DPAD3].y = 0;
+	Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_DPAD3].w = 0;
+	Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_DPAD3].h = 0;
+	// Hide hook button
+	Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_0].x = 0;
+	Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_0].y = 0;
+	Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_0].w = 0;
+	Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_0].h = 0;
+	// Weapnext button above joystick
+	Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_1].x =
+		ScreenW - Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_1].w;
+	Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_1].y =
+		Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_DPAD].y -
+		Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_1].h * 2;
+	// Fire button to the left
+	Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_2].w *= 1.5f;
+	Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_2].h *= 1.5f;
+	Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_2].x = 0;
+	Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_2].y =
+		ScreenH - Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_2].h;
+	// Jump button to the right of fire button
+	Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_4].w = Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_2].w;
+	Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_4].h = Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_2].h;
+	Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_4].x =
+		Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_2].w;
+	Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_4].y =
+		Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_2].y;
+	// Scores button above jump button
+	Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_3].x = 0;
+	Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_3].y =
+		Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_3].h;
+	// Text input button above scores
+	Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_TEXT].y =
+		Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_3].y -
+		Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_TEXT].h;
 }
 
+static void AndroidScreenKeysDDRace(SDL_Rect Buttons[], int ScreenW, int ScreenH)
+{
+	// Second joystick to the right
+	Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_DPAD2].w *= 0.9;
+	Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_DPAD2].h *= 0.9;
+	Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_DPAD2].x =
+		ScreenW - Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_DPAD2].w;
+	Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_DPAD2].y =
+		ScreenH - Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_DPAD2].h;
+	// Hide third joystick
+	Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_DPAD3].x = 0;
+	Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_DPAD3].y = 0;
+	Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_DPAD3].w = 0;
+	Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_DPAD3].h = 0;
+	// Fire button above right joystick
+	Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_2].x =
+		ScreenW - Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_2].w;
+	Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_2].y =
+		Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_DPAD2].y -
+		Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_2].h;
+	// Hide Hook button
+	Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_0].x = 0;
+	Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_0].y = 0;
+	Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_0].w = 0;
+	Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_0].h = 0;
+	// Weapnext button above left joystick
+	Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_1].x = 0;
+	Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_1].y =
+		Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_DPAD].y -
+		Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_1].h;
+	// Scores button above left joystick
+	Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_3].x = 0;
+	Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_3].y =
+		Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_DPAD].y -
+		Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_3].h * 2;
+	// Text input button above scores
+	Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_TEXT].y =
+		Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_3].y -
+		Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_TEXT].h;
+}
+
+static void AndroidScreenKeysVolumeKeys(SDL_Rect Buttons[], int ScreenW, int ScreenH)
+{
+	// Both volume buttons will launch hook
+	SDL_ANDROID_SetAndroidKeycode(24, SDLK_RETURN);
+	SDL_ANDROID_SetAndroidKeycode(25, SDLK_RETURN);
+
+	// Second joystick to the right
+	Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_DPAD2].w *= 0.9;
+	Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_DPAD2].h *= 0.9;
+	Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_DPAD2].x =
+		ScreenW - Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_DPAD2].w;
+	Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_DPAD2].y =
+		ScreenH - Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_DPAD2].h;
+	// Hide third joystick
+	Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_DPAD3].x = 0;
+	Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_DPAD3].y = 0;
+	Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_DPAD3].w = 0;
+	Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_DPAD3].h = 0;
+	// Hide fire button
+	Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_2].x = 0;
+	Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_2].y = 0;
+	Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_2].w = 0;
+	Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_2].h = 0;
+	// Hide Hook button
+	Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_0].x = 0;
+	Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_0].y = 0;
+	Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_0].w = 0;
+	Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_0].h = 0;
+	// Weapnext button above left joystick
+	Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_1].x = 0;
+	Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_1].y =
+		Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_DPAD].y -
+		Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_1].h;
+	// Scores button above left joystick
+	Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_3].x = 0;
+	Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_3].y =
+		Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_DPAD].y -
+		Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_3].h * 2;
+	// Text input button above scores
+	Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_TEXT].y =
+		Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_3].y -
+		Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_TEXT].h;
+}
+#endif
+
+void CUI::AndroidShowScreenKeys(bool shown)
+{
+#if defined(__ANDROID__)
+	static bool ScreenKeyboardInitialized = false;
+	static bool ScreenKeyboardShown = true;
+	static SDL_Rect Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_NUM];
+	static SDL_Rect ButtonsInit[SDL_ANDROID_SCREENKEYBOARD_BUTTON_NUM];
+	static SDL_Rect ButtonHidden = { 0, 0, 0, 0 };
+	static int PreviousTouchscreenMode = -1;
+
+	if( !ScreenKeyboardInitialized )
+	{
+		ScreenKeyboardInitialized = true;
+
+		for( int i = 0; i < SDL_ANDROID_SCREENKEYBOARD_BUTTON_NUM; i++ )
+			SDL_ANDROID_GetScreenKeyboardButtonPos( i, &ButtonsInit[i] );
+	}
+
+	if( PreviousTouchscreenMode != g_Config.m_ClTouchscreenMode && !SDL_ANDROID_GetScreenKeyboardRedefinedByUser() )
+	{
+		PreviousTouchscreenMode = g_Config.m_ClTouchscreenMode;
+
+		for( int i = 0; i < SDL_ANDROID_SCREENKEYBOARD_BUTTON_NUM; i++ )
+			Buttons[i] = ButtonsInit[i];
+		// Remove keycodes from Volume keys
+		SDL_ANDROID_SetAndroidKeycode(24, 0);
+		SDL_ANDROID_SetAndroidKeycode(25, 0);
+
+		int ScreenW = Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_DPAD2].x +
+						Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_DPAD2].w;
+		int ScreenH = Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_DPAD2].y +
+						Buttons[SDL_ANDROID_SCREENKEYBOARD_BUTTON_DPAD2].h;
+
+		switch( g_Config.m_ClTouchscreenMode )
+		{
+			case TOUCHSCREEN_TWO_JOYSTICKS:
+				AndroidScreenKeysTwoJoysticks(Buttons, ScreenW, ScreenH);
+				break;
+			case TOUCHSCREEN_THREE_JOYSTICKS:
+				AndroidScreenKeysThreeJoysticks(Buttons, ScreenW, ScreenH);
+				break;
+			case TOUCHSCREEN_ACCELEROMETER:
+				AndroidScreenKeysAccelerometer(Buttons, ScreenW, ScreenH);
+				break;
+			case TOUCHSCREEN_DDRACE:
+				AndroidScreenKeysDDRace(Buttons, ScreenW, ScreenH);
+				break;
+			case TOUCHSCREEN_VOLUME_KEYS:
+				AndroidScreenKeysVolumeKeys(Buttons, ScreenW, ScreenH);
+				break;
+		}
+	}
+
+	if( ScreenKeyboardShown == shown )
+		return;
+	ScreenKeyboardShown = shown;
+
+	for( int i = 0; i < SDL_ANDROID_SCREENKEYBOARD_BUTTON_NUM; i++ )
+		SDL_ANDROID_SetScreenKeyboardButtonPos( i, shown ? &Buttons[i] : &ButtonHidden );
+#endif
+}
+
+void CUI::AndroidShowTextInput(const char *text)
+{
+#if defined(__ANDROID__)
+	SDL_ANDROID_ToggleScreenKeyboardTextInput(text);
+#endif
+}
+
+void CUI::AndroidTextInputHintMessage(const char *hintText)
+{
+#if defined(__ANDROID__)
+	SDL_ANDROID_SetScreenKeyboardHintMesage(hintText);
+#endif
+}
+
+void CUI::AndroidBlockAndGetTextInput(char *text, int textLength, const char *hintText)
+{
+#if defined(__ANDROID__)
+	SDL_ANDROID_SetScreenKeyboardHintMesage(hintText);
+	SDL_ANDROID_GetScreenKeyboardTextInput(text, textLength);
+#endif
+}
+
+bool CUI::AndroidTextInputShown()
+{
+#if defined(__ANDROID__)
+	return SDL_IsScreenKeyboardShown(NULL);
+#else
+	return false;
+#endif
+}
+
+
 CUIRect *CUI::Screen()
 {
 	float Aspect = Graphics()->ScreenAspect();
diff --git a/src/game/client/ui.h b/src/game/client/ui.h
index daba5d5..3784974 100644
--- a/src/game/client/ui.h
+++ b/src/game/client/ui.h
@@ -95,6 +95,12 @@ public:
 	// TODO: Refactor: Remove this?
 	void DoLabel(const CUIRect *pRect, const char *pText, float Size, int Align, int MaxWidth = -1);
 	void DoLabelScaled(const CUIRect *pRect, const char *pText, float Size, int Align, int MaxWidth = -1);
+
+	void AndroidShowScreenKeys(bool shown);
+	void AndroidShowTextInput(const char *text);
+	void AndroidTextInputHintMessage(const char *hintText);
+	void AndroidBlockAndGetTextInput(char *text, int textLength, const char *hintText);
+	bool AndroidTextInputShown();
 };
 
 
diff --git a/src/game/variables.h b/src/game/variables.h
index 1cc329a..b1b02a9 100644
--- a/src/game/variables.h
+++ b/src/game/variables.h
@@ -11,7 +11,11 @@ MACRO_CONFIG_INT(ClNameplates, cl_nameplates, 1, 0, 1, CFGFLAG_CLIENT|CFGFLAG_SA
 MACRO_CONFIG_INT(ClNameplatesAlways, cl_nameplates_always, 1, 0, 1, CFGFLAG_CLIENT|CFGFLAG_SAVE, "Always show name plates disregarding of distance")
 MACRO_CONFIG_INT(ClNameplatesTeamcolors, cl_nameplates_teamcolors, 1, 0, 1, CFGFLAG_CLIENT|CFGFLAG_SAVE, "Use team colors for name plates")
 MACRO_CONFIG_INT(ClNameplatesSize, cl_nameplates_size, 50, 0, 100, CFGFLAG_CLIENT|CFGFLAG_SAVE, "Size of the name plates from 0 to 100%")
-MACRO_CONFIG_INT(ClAutoswitchWeapons, cl_autoswitch_weapons, 0, 0, 1, CFGFLAG_CLIENT|CFGFLAG_SAVE, "Auto switch weapon on pickup")
+MACRO_CONFIG_INT(ClAutoswitchWeapons, cl_autoswitch_weapons, 1, 0, 1, CFGFLAG_CLIENT|CFGFLAG_SAVE, "Auto switch weapon on pickup")
+MACRO_CONFIG_INT(ClAutoswitchWeaponsOutOfAmmo, cl_autoswitch_weapons_out_of_ammo, 1, 0, 1, CFGFLAG_CLIENT|CFGFLAG_SAVE, "Auto switch weapon when out of ammo")
+
+MACRO_CONFIG_INT(ClTouchscreenMode, cl_touchscreen_mode_2, TOUCHSCREEN_ACCELEROMETER, TOUCHSCREEN_TWO_JOYSTICKS, TOUCHSCREEN_VOLUME_KEYS, CFGFLAG_CLIENT|CFGFLAG_SAVE, "Touchscreen controls preset")
+MACRO_CONFIG_INT(ClAccelerometerSensitivity, cl_accelerometer_sensitivity, 2000, 0, 10000, CFGFLAG_CLIENT|CFGFLAG_SAVE, "Accelerometer sensitivity")
 
 MACRO_CONFIG_INT(ClShowhud, cl_showhud, 1, 0, 1, CFGFLAG_CLIENT|CFGFLAG_SAVE, "Show ingame HUD")
 MACRO_CONFIG_INT(ClShowChatFriends, cl_show_chat_friends, 0, 0, 1, CFGFLAG_CLIENT|CFGFLAG_SAVE, "Show only chat messages from friends")
@@ -22,9 +26,9 @@ MACRO_CONFIG_INT(ClThreadsoundloading, cl_threadsoundloading, 0, 0, 1, CFGFLAG_C
 
 MACRO_CONFIG_INT(ClWarningTeambalance, cl_warning_teambalance, 1, 0, 1, CFGFLAG_CLIENT|CFGFLAG_SAVE, "Warn about team balance")
 
-MACRO_CONFIG_INT(ClMouseDeadzone, cl_mouse_deadzone, 300, 0, 0, CFGFLAG_CLIENT|CFGFLAG_SAVE, "")
+MACRO_CONFIG_INT(ClMouseDeadzone, cl_mouse_deadzone, 800, 0, 0, CFGFLAG_CLIENT|CFGFLAG_SAVE, "") // Disable dynamic camera on Android, screen becomes jerky when you tap joystick
 MACRO_CONFIG_INT(ClMouseFollowfactor, cl_mouse_followfactor, 60, 0, 200, CFGFLAG_CLIENT|CFGFLAG_SAVE, "")
-MACRO_CONFIG_INT(ClMouseMaxDistance, cl_mouse_max_distance, 800, 0, 0, CFGFLAG_CLIENT|CFGFLAG_SAVE, "")
+MACRO_CONFIG_INT(ClMouseMaxDistance, cl_mouse_max_distance, 400, 0, 0, CFGFLAG_CLIENT|CFGFLAG_SAVE, "") // Prevent crosshair from moving out of screen on Android
 
 MACRO_CONFIG_INT(EdShowkeys, ed_showkeys, 0, 0, 1, CFGFLAG_CLIENT|CFGFLAG_SAVE, "")
 
